var Coder = require('../lib/Coder')
var Protocol = require('../lib/Protocol')
var Tools = require('../lib/Tools')


// Generated by CoffeeScript 2.5.1
var JRPCCallback, JRPCError, JRPCInfo, JRPCMethod, JRPCProtocol, JRPCRequest;

JRPCRequest = class JRPCRequest {
  constructor(id) {
    if (id) {
      this.id = id;
    }
    this.jsonrpc = '2.0';
  }

};

JRPCMethod = class JRPCMethod extends JRPCRequest {
  constructor(method, id, params = [], cbs) {
    super(id);
    this.method = method;
    this.params = params;
    if (cbs) {
      this.cbs = cbs;
    }
  }

};

JRPCCallback = class JRPCCallback extends JRPCRequest {
  constructor(id1, params = [], cbs) {
    super(id);
    this.id = id1;
    this.params = params;
    if (cbs) {
      this.cbs = cbs;
    }
  }

};

JRPCError = class JRPCError extends JRPCRequest {
  constructor(code, message, id) {
    super(id);
    // @result = null
    this.error = {
      code: code,
      message: message
    };
  }

};

JRPCInfo = class JRPCInfo extends JRPCRequest {
  constructor(id1, server, client) {
    super(id);
    this.id = id1;
    if (server) {
      this.server = server;
    }
    if (client) {
      this.client = client;
    }
  }

};

JRPCProtocol = (function() {
  class JRPCProtocol extends Protocol {
    // Response processing
    constructor() {
      var methodsInfo;
      super();
      methodsInfo = {
        type: 'Array',
        value: {
          type: ['Object', 'String'],
          props: {
            name: Model.required('String'),
            info: Model.required('String'),
            args: {
              type: 'Array',
              value: {
                type: 'Object',
                props: {
                  name: Model.required('String'),
                  type: Model.required('String'),
                  info: Model.required('String')
                }
              }
            },
            ret: 'String'
          }
        }
      };
      this.model = {
        method: new Model(this, {
          method: Model.required('String'),
          params: Model.required('Array'),
          id: 'String',
          cbs: 'Array'
        }),
        callback: new Model(this, {
          result: Model.required('Array'),
          id: 'String',
          cbs: 'Array'
        }),
        error: new Model(this, {
          error: {
            type: Model.required('Object'),
            props: {
              code: Model.required('Number'),
              message: Model.required('String')
            }
          },
          id: 'String'
        }),
        info: new Model(this, {
          id: Model.required('String'),
          server: methodsInfo,
          client: methodsInfo
        })
      };
    }

    // Response processing
    parse(request) {
      var id;
      super.parse();
      id = request.id ? request.id.toString() : null;
      if (request.method) {
        this.model.method.validate(this, request);
        return new Protocol.Method(request.method, id, request.params, request.cbs);
      } else if (request.error) {
        this.model.error.validate(this, request);
        return new Protocol.Error(err.message, err.code, id);
      } else if (request.result) {
        this.model.callback.validate(this, request);
        return new Protocol.Callback(id, request.result, request.cbs);
      // Reqs custom property (?)
      } else if (request.info) {
        this.model.info.validate(this, request);
        return new Protocol.Info(id, request.server, request.client);
      } else {
        return this.throw(`Unknown request: '${JSON.stringify(request)}'`);
      }
    }

  };

  JRPCProtocol.prototype.Method = JRPCMethod;

  JRPCProtocol.prototype.Callback = JRPCCallback;

  JRPCProtocol.prototype.Error = JRPCError;

  JRPCProtocol.prototype.Info = JRPCInfo;

  return JRPCProtocol;

}).call(this);

module.exports = JRPCProtocol;

//# sourceMappingURL=JRPCProtocol.js.map
