var Coder = require('./lib/Coder')
var Protocol = require('./lib/Protocol')
var Tools = require('./lib/Tools')


// Generated by CoffeeScript 2.5.1
  /*
  Reqs class
  @class
  */
var Reqs,
  hasProp = {}.hasOwnProperty;

Reqs = (function() {
  var argsConvertCb2Id, argsConvertId2Cb, callbackRequest;

  class Reqs {
    // ################### #
    // --- Constructor --- #
    // ################### #
    /*
    Create Reqs API instance
    @constructor
    @param {object} options
    */
    constructor(options = {}) {
      var coder, coderArgs, f, name, protocol, protocolArgs, ref, sArgs;
      this.events = Tools.null();
      this.methods = Tools.null();
      this.isSession = false;
      this._callbacks = Tools.null(); // Callbacks container
      this._id = 0; // Callbacks counter
      this._promises = Tools.null(); // Promises xt container
      this._pid = 0; // Promises counter
      
      // Adding events handlers
      if (options.events) {
        ref = options.events;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          f = ref[name];
          this.events[name] = f;
        }
      }
      // Adding methods
      if (options.methods) {
        this.addMethods(options.methods);
      }
      // Saving some options for inheritance
      // when session will be created
      this.options = {
        methods: options.methods || {},
        session: options.session
      };
      // Setting send function
      if (options.send) {
        this.send = options.send;
      }
      // Processing error options
      if (options.error) {
        this.error = options.error;
      }
      // ID Generators
      if (options.newid) {
        this.newid = options.newid;
      }
      if (options.newpid) {
        this.newpid = options.newpid;
      }
      // Set coder
      coderArgs = options.key ? [options.key] : [];
      if (options.coder) {
        if (Tools.isString(options.coder)) {
          coder = Reqs.coders[options.coder];
        } else {
          coder = Reqs.coders[options.coder.name || Reqs.default.coder];
          if (options.coder.arguments) {
            coderArgs = options.coder.arguments;
          }
        }
        if (!coder) {
          throw new Error(`Unknown coder: '${options.coder}'`);
        }
      } else {
        coder = Reqs.coders[Reqs.default.coder];
      }
      this.coder = new coder(...coderArgs);
      // Set protocol
      protocolArgs = [];
      if (options.protocol) {
        if (Tools.isString(options.protocol)) {
          protocol = Reqs.protocols[options.protocol];
        } else {
          protocol = Reqs.protocols[options.protocol.name || Reqs.default.protocol];
          if (options.protocol.arguments) {
            protocolArgs = options.protocol.arguments;
          }
        }
        if (!protocol) {
          throw new Error(`Unknown protocol: '${options.protocol}'`);
        }
      } else {
        protocol = Reqs.protocols[Reqs.default.protocol];
      }
      this.protocol = new protocol(...protocolArgs);
      // Processing session options
      if (options.session) {
        // Save custom arguments names
        sArgs = options.session.arguments;
        if (Tools.isString(sArgs)) {
          this.options.session.arguments = [sArgs];
        } else if (Tools.isArray(sArgs)) {
          this.options.session.arguments = sArgs;
        }
      } else {
        this.options.session = {
          arguments: []
        };
      }
      Object.defineProperty(this, 'async', {
        get: () => {
          return this._async;
        },
        set: (value) => {
          return this.asyncSet(value);
        }
      });
      this.async = Tools.isBoolean(options.mode) ? options.mode === 'async' : Reqs.default.mode === 'async';
    }

    // #################### #
    // --- Main methods --- #
    // #################### #
    /*
    Parse the request data.
    @param {string} request — the string/buffer/whatever from client/server
    (allow to transfer any user data from data input point to API functions)
    @return {object} result — result of API call (can be undefined or null)
    */
    parse(data) {
      var decodedData, e, j, len, request, result;
      try {
        decodedData = this.coder.decode(data);
      } catch (error) {
        e = error;
        return this.err400(`Data processing error: ${e.message}\n${e.stack}`);
      }
      try {
        if (Tools.isArray(decodedData)) {
          for (j = 0, len = decodedData.length; j < len; j++) {
            request = decodedData[j];
            result = this.processRequest(request);
          }
        } else {
          result = this.processRequest(decodedData);
        }
      } catch (error) {
        e = error;
        return this.err400(`Request parsing error: ${e.message}\n${e.stack}`);
      }
      return result;
    }

    processRequest(data) {
      var args, e, id, method, promiseXt, protocol, request, response, result, types, xt;
      request = this.protocol.parse(data);
      protocol = this.protocol;
      types = protocol.types;
      id = request.id;
      switch (request.type) {
        // ##################################################
        // API Method handling
        case types.method:
          method = request.method;
          xt = this.events[method];
          if (xt) {
            args = argsConvertId2Cb(this, request.args, request.cbs);
            if (id) { // This request was created with promise (async mode)
              // Normal processing
              try {
                result = xt.apply(this, args);
                if (result instanceof Promise) {
                  result.then((promiseResult) => {
                    return this.request(new protocol.Resolve(id, promiseResult));
                  }).catch((promiseErr) => {
                    return this.request(new protocol.Reject(id, promiseErr.toString()));
                  });
                  return result;
                } else {
                  response = new protocol.Resolve(id, result);
                }
              } catch (error) {
                e = error; // Errors processing
                response = new protocol.Reject(id, e.toString());
              }
              return this.request(response); // Client/server don't want result (or, callbacks is used) (sync mode)
            } else {
              return xt.apply(this, args);
            }
          } else {
            return this.err404(`Method not found: <${method}>.`);
          }
          break;
        // ##################################################
        // Callback handling
        case types.callback:
          xt = this._callbacks[id];
          if (xt === void 0) {
            return this.err404(`Wrong callback ID: <${id}>.`);
          }
          delete this._callbacks[id];
          args = argsConvertId2Cb(this, request.args, request.cbs);
          return xt.apply(this, args || []);
        case types.resolve:
          promiseXt = this._promises[id];
          delete this._promises[id];
          if (promiseXt && promiseXt.resolve) {
            return promiseXt.resolve.call(this, request.resolve);
          } else {
            return this.err404(`Wrong resolve promise ID: <${id}>.`);
          }
          break;
        case types.reject:
          promiseXt = this._promises[id];
          delete this._promises[id];
          if (promiseXt && promiseXt.reject) {
            return promiseXt.reject.call(this, request.reject);
          } else {
            return this.err404(`Wrong reject promise ID: <${id}>.`);
          }
          break;
        case types.info:
          if (id) {
            // TODO: add full details sending
            return this.request(new protocol.Callback(id, [
              Object.keys(this.methods), // -> events for connected client
              Object.keys(this.events) // -> methods for connected client
            ]));
          }
          break;
        case types.error:
          return this.err422(`Error request. Code: '${request.code}'. ${request.message}`);
        default:
          return this.err422(`Unknown request type: '${request.type}'.`);
      }
      return null;
    }

    /*
    Encode and send request
    @param {object} request — request object
    */
    request(request) {
      return this.send(this.coder.encode(request));
    }

    // ############################## #
    // --- Error handling methods --- #
    // ############################## #
    /*
    Error 'Input data decoding error or wrong input data'
    @param {string} message — error message
    */
    err400(message) {
      return this.error(message, 400);
    }

    /*
    Error 'API Method or callback not found'
    @param {string} message — error message
    */
    err404(message) {
      return this.error(message, 404);
    }

    /*
    Error 'Wrong data input'
    @param {string} message — error message
    */
    err422(message) {
      return this.error(message, 422);
    }

    /*
    Error rised during processing request
    @param {number} code — error code
    @param {string} message — error message
    */
    error(message, code) {
      return console.warn(code, message);
    }

    /*
    Send error message to client/server
    @param {string} id — request id
    @param {number} code — error code
    @param {string} message — error message
    */
    sendError(message, code, id) {
      return this.request(new this.protocol.Error(message, code, id));
    }

    // ########################## #
    // --- Options in runtime --- #
    // ########################## #
    /*
    Set method's executing mode: async or sync
    @param {boolean} value — async or sync mode
    */
    asyncSet(value) {
      this._async = value;
      this.methodApply = value ? this.methodAsyncApply : this.methodSyncApply;
    }

    /*
    Set coder by name
    @param {string} coder — coder name
    */
    coderSet(coder) {
      return this.coder = Reqs.coders[coder];
    }

    /*
    Set protocol by name
    @param {string} protocol — protocol name
    */
    protocolSet(protocol) {
      return this.protocol = Reqs.protocols[protocol];
    }

    /*
    Use module
    @param {Class} module — module to use
    */
    use(module, ...args) {
      return this[module.option] = new module(...args);
    }

    // ################################## #
    // --- Callbacks handling methods --- #
    // ################################## #
    /*
    Create callback function with cached ID and session and return it.
    @param {string} id — ID of callback
    @return {function} xt — function with cached id and current Reqs API session
    */
    createCallback(id) {
      var api, newCb;
      api = this;
      newCb = function() {
        return callbackRequest(api, id, arguments);
      };
      newCb.created = Date.now(); // Callback creation time - required for callbacks dispose in runtime
      return newCb;
    }

    /*
    Generate new ID for callback or promise.
    @return {string} id — callback ID as string
    */
    newid() {
      if (this._id === Number.MAX_SAFE_INTEGER) {
        this._id = 0;
      }
      return (++this._id).toString();
    }

    /*
    Generate new promise ID for async request.
    @return {string} id — promise ID as string
    */
    newpid() {
      if (this._pid === Number.MAX_SAFE_INTEGER) {
        this._pid = 0;
      }
      return (++this._pid).toString();
    }

    /*
    Add callback and return it's ID. By default ID is a simple counter.
    Callbacks starts from 1 and up to Number.MAX_SAFE_INTEGER.
    Transfers as a string for case if server/client can have
    Number.MAX_SAFE_INTEGER less, then client/server and custom ID generators.
    @param {function} cb — callback function
    @return {string} id — callback's ID
    */
    addCallback(cb) {
      var id;
      id = this.newid();
      this._callbacks[id] = cb;
      return id;
    }

    /*
    Call method with next arguments.
    Mode (async/sync) depends on this.async flag.
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    method(method, ...args) {
      return this.methodApply(method, args);
    }

    /*
    Call method asynchronously with next arguments
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    methodAsync(method, ...args) {
      return this.methodAsyncApply(method, args);
    }

    /*
    Call method synchronously with next arguments
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    methodSync(method, ...args) {
      return this.methodSyncApply(method, args);
    }

    /*
    Apply method asynchronously with arguments
    @param {string} method — method name
    @param {arrayLike} args — arguments array-like object (arguments)
    @param {array} args — arguments array
    */
    methodAsyncApply(method, args) {
      var cbs, convertedArgs, pid, promise;
      [convertedArgs, cbs] = argsConvertCb2Id(this, args);
      pid = this.newpid();
      promise = new Promise((resolve, reject) => {
        return this._promises[pid] = {resolve, reject};
      });
      this.request(new this.protocol.Method(method, pid, convertedArgs, cbs)); // Request sending
      return promise;
    }

    /*
    Apply method synchronously with arguments
    @param {string} method — method name
    @param {arrayLike} args — arguments array-like object (arguments)
    @param {array} args — arguments array
    */
    methodSyncApply(method, args) {
      var cbs, convertedArgs;
      [convertedArgs, cbs] = argsConvertCb2Id(this, args);
      return this.request(new this.protocol.Method(method, null, convertedArgs, cbs)); // Request sending
    }

    /*
    Create function-wrapper for API calls.
    Usefull for data preprocessing before send.
    Arguments of xt will be sended to client/server directly.
    Session and method's name is cahced.
    @param {string} method — method's name, will be cached
    @return {object} this
    */
    addMethod(method) {
      var api;
      api = this;
      this.methods[method] = function() {
        return api.methodApply(method, arguments);
      };
      return this;
    }

    /*
    Create function-wrapper for API calls for selected function.
    Allow to prepare arguments or callback for server.
    Session and name is cahced.
    @param {string} functionName — function name, will be cached
    @param {function} xt — function, will be called before request sending
    @param {function} xtThen — function, attached to promise via 'then' method
    @param {function} xtCatch — function, attached to promise via 'catch' method
    @return {object} this
    */
    createMethod(method, xt, mode, xtThen, xtCatch, safe = true) {
      var api, methods, mxt;
      api = this;
      methods = this.methods;
      if (safe && methods[method]) {
        return;
      }
      if (mode === void 0) {
        if (xt) {
          methods[method] = function() {
            return api.methodApply(method, xt.apply(api, arguments));
          };
        } else {
          methods[method] = function() {
            return api.methodApply(method, arguments);
          };
        }
      } else if (mode === 'async') {
        if (xtThen && xtCatch) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen).catch(xtCatch);
          } : function() {
            return api.methodAsyncApply(method, arguments).then(xtThen).catch(xtCatch);
          };
        } else if (xtThen) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen);
          } : function() {
            return api.methodAsyncApply(method, arguments).then(xtThen);
          };
        } else if (xtCatch) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).catch(xtCatch);
          } : function() {
            return api.methodAsyncApply(method, arguments).catch(xtCatch);
          };
        } else {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments));
          } : function() {
            return api.methodAsyncApply(method, arguments);
          };
        }
        methods[method] = mxt;
      } else {
        methods[method] = xt ? function() {
          return api.methodSyncApply(method, xt.apply(api, arguments));
        } : function() {
          return api.methodSyncApply(method, arguments);
        };
      }
      return this;
    }

    /*
    Create API methods. Basically just wrap function into another function
    with cached context (API instance or session) and method name.
    @param {array} methodsList — string array with function names
    @param {object} methodsList — object with functions for data preprocessing
    @param {safe} safe — do not overwrite existsing methods (true by default)
    @return {object} this
    */
    addMethods(methodsList, safe) {
      var j, len, m, method, methods, name;
      methods = this.methods;
      if (Tools.isArray(methodsList)) {
        for (j = 0, len = methodsList.length; j < len; j++) {
          method = methodsList[j];
          if (Tools.isString(method)) {
            if (methods[method]) {
              continue;
            }
            this.addMethod(method);
          } else if (Tools.isObject(method)) {
            for (name in method) {
              if (!hasProp.call(method, name)) continue;
              m = method[name];
              if (methods[name]) {
                continue;
              }
              if (Tools.isFunction(m)) {
                this.createMethod(name, m, null, null, null, safe);
              } else {
                this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
              }
            }
          }
        }
      } else if (Tools.isObject(methodsList)) {
        for (name in methodsList) {
          if (!hasProp.call(methodsList, name)) continue;
          m = methodsList[name];
          if (methods[name]) {
            continue;
          }
          if (Tools.isFunction(m)) {
            this.createMethod(name, m, null, null, null, safe);
          } else {
            this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
          }
        }
      }
      return this;
    }

    /*
    Get info about server's API
    @param {string} [methodName] — methodName
    @param {function} cb — callback for result processing
    @return {object}
    */
    info(cb, options = {}) {
      var id;
      if (!Tools.isFunction(cb)) {
        throw new Error('Reqs.info() call without callback for data.');
      }
      // @request INFO: methodName, CB: @addCallback cb
      id = this.addCallback(cb);
      return this.request(new this.protocol.Info(id, options.events, options.methods));
    }

    /*
    Collect server's API methods list and create local client API methods
    @param {function} cb — callback
    @return {object} this
    */
    build(cb) {
      this.info((events, methods) => {
        this.addMethods(methods);
        if (Tools.isFunction(cb)) {
          return cb(events, methods);
        }
      });
      return this;
    }

    // ########################## #
    // --- Modules management --- #
    // ########################## #
    static addModule(m) {
      var modulesContainer;
      modulesContainer = this[m.category];
      if (!modulesContainer) {
        modulesContainer = this[m.category] = Tools.null();
      }
      modulesContainer[m.name] = m;
      return m;
    }

    // ########################### #
    // --- Sessions management --- #
    // ########################### #
    /*
    Create new session (child for current Reqs API)
    @param {object} [context][arg_1...arg_n] — user-defined argument
    or arguments for adding to session object as properties.
    If options.session.arguments is empty, then first argument will be
    saved to <Session>.context property.
    If options.session.arguments array is defined, then will be used
    this list of arguments names for defining the properties of session.
    @return {Session} session — session instance nested from Reqs API instance.
    */
    new() {
      var i, j, len, prop, ref, session;
      // Check for correct session creation: session must be
      // inherited from Reqs API instance, not from session.
      if (this.isSession) {
        throw new Error('<Reqs.Session instance>.new() used for new session creation. Use insted "<Reqs instance>.new()".');
      }
      // Creating of session instance nested from current Reqs API
      session = Object.create(this);
      // Adding user-defined properties
      if (arguments.length > 0) {
        ref = this.options.session.arguments;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          prop = ref[i];
          session[prop] = arguments[i];
        }
      }
      // Setting session properties
      session.isSession = true; // Is this object is session
      session.created = Date.now(); // Session creation date
      session.reqs = this; // Parent Reqs API instance
      session._callbacks = Tools.null(); // This session callbacks list
      session._id = 0; // Callbacks ID counter
      session._promises = Tools.null();
      session._pid = 0;
      session.methods = Tools.null(); // Session client API functions
      session.addMethods(this.options.methods); // Methods creation (required for caching session)
      return session;
    }

  };

  // ####################### #
  // --- Default options --- #
  // ####################### #

  // Is methods async (returns promise) or not (returns options.send result)
  Reqs.default = {
    mode: 'sync',
    coder: 'Coder',
    protocol: 'Protocol'
  };

  // ############### #
  // --- Modules --- #
  // ############### #
  Reqs.protocols = Tools.null({Protocol});

  Reqs.coders = Tools.null({Coder});

  // ############################## #
  // --- Tools and constructors --- #
  // ############################## #
  Reqs.Tools = Tools;

  Reqs.Protocol = Protocol;

  Reqs.Coder = Coder;

  /*
  Send compiled request to server/client.
  @param {string} data — data for sending (default: JSON string)
  */
  Reqs.prototype.send = console.info;

  // ###################################### #
  // --- Callbacks arguments converters --- #
  // ###################################### #
  argsConvertCb2Id = function(api, requestArgs = []) {
    var arg, args, cbs, i, j, len;
    args = [];
    cbs = [];
// Converting object to array
    for (i = j = 0, len = requestArgs.length; j < len; i = ++j) {
      arg = requestArgs[i];
      if (Tools.isFunction(arg)) {
        arg = api.addCallback(arg);
        cbs.push(Number.parseInt(i)); // For array-like objects 'arguments' case
      }
      args.push(arg);
    }
    if (cbs.length === 0) {
      cbs = null;
    }
    return [args, cbs];
  };

  argsConvertId2Cb = function(api, args = [], cbs) {
    var callbackId, id, j, len;
    if (cbs === void 0 || cbs.length === 0) {
      return args;
    }
// Converting object to array
    for (j = 0, len = cbs.length; j < len; j++) {
      id = cbs[j];
      callbackId = args[id];
      args[id] = api.createCallback(callbackId);
    }
    return args;
  };

  callbackRequest = function(api, id, cbArgs) {
    var args, cbs;
    [args, cbs] = argsConvertCb2Id(api, cbArgs);
    return api.request(new api.protocol.Callback(id, args, cbs)); // Request sending
  };

  return Reqs;

}).call(this);

module.exports = Reqs;

//# sourceMappingURL=reqs.js.map
