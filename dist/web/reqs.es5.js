function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

this.Reqs = function (module) {
  // Generated by CoffeeScript 2.5.1
  var Coder;

  Coder = function () {
    var Coder =
    /*#__PURE__*/
    function () {
      "use strict";

      _createClass(Coder, [{
        key: "encodeKey",
        value: function encodeKey(request) {
          request.key = this.key;
          return JSON.stringify(request);
        }
      }, {
        key: "decodeKey",
        value: function decodeKey(data) {
          var request;
          request = JSON.parse(data);

          if (request.key !== this.key) {
            throw new Error("Wrong API Key");
          }

          delete request.key;
          return request;
        }
      }]);

      function Coder(key) {
        _classCallCheck(this, Coder);

        if (key) {
          this.key = key;
          this.encode = this.encodeKey;
          this.decode = this.decodeKey;
        }
      }

      return Coder;
    }();

    ;
    Coder.category = 'coders';
    Coder.option = 'coder';
    /*
    Default encode function from object to data
    @param {object} object — object with request
    @return {string} data — output data; object, encoded to string/buffer/whatever format
    */

    Coder.prototype.encode = JSON.stringify;
    /*
    Default decode function from data to object
    @param {string} data — input request in string/buffer/whatever format
    @return {object} object — decoded object from data
    */

    Coder.prototype.decode = JSON.parse;
    return Coder;
  }.call(this); // Generated by CoffeeScript 2.5.1
  // Base classes for all requests types.
  // 1. For requests creation from incoming data
  // 2. Default data type for sending
  // Requests types


  var Model,
      Protocol,
      ReqsCallback,
      ReqsError,
      ReqsInfo,
      ReqsMethod,
      ReqsReject,
      ReqsRequest,
      ReqsResolve,
      types,
      hasProp = {}.hasOwnProperty;
  types = {
    none: 0,
    method: 1,
    callback: 2,
    resolve: 3,
    reject: 4,
    error: 5,
    info: 6,
    0: 'none',
    1: 'method',
    2: 'callback',
    3: 'resolve',
    4: 'reject',
    5: 'error',
    6: 'info'
  };

  Model = function () {
    var Property;

    var Model =
    /*#__PURE__*/
    function () {
      "use strict";

      function Model(props) {
        _classCallCheck(this, Model);

        var name, prop;
        this.props = [];

        for (name in props) {
          if (!hasProp.call(props, name)) continue;
          prop = props[name];
          this.props.push(new Property(name, prop));
        }
      }

      _createClass(Model, [{
        key: "validate",
        value: function validate(protocol, object) {
          var j, len, prop, ref;
          ref = this.props;

          for (j = 0, len = ref.length; j < len; j++) {
            prop = ref[j];
            prop.validate(protocol, object);
          }

          return this;
        }
      }], [{
        key: "required",
        value: function required(type) {
          var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return Object.assign(props, {
            type: type,
            required: true
          });
        }
      }]);

      return Model;
    }();

    ;

    Property =
    /*#__PURE__*/
    function () {
      "use strict";

      /*
      @class
      @param {string} name — property name
      @param {string} optionsOrType — property type
      @param {object} optionsOrType — property options:
          {array} types — list of allowed property types
          {boolean} [required] — is property required in object or not
          {object} [value] — value property for Array type value
          {object} [props] — properties for object type
      */
      function Property(name1, optionsOrType) {
        _classCallCheck(this, Property);

        var j, len, name, options, prop, ref, ref1, t;
        this.name = name1;

        if (Tools.isString(optionsOrType)) {
          options = {
            type: [optionsOrType]
          };
        } else {
          options = optionsOrType;

          if (Tools.isString(options.type)) {
            options.type = [options.type];
          }
        }

        this.type = Tools.null();
        ref = options.type;

        for (j = 0, len = ref.length; j < len; j++) {
          t = ref[j];
          this.type[t] = true;
        }

        this.required = options.required !== void 0 ? options.required : false; // for array type

        if (options.value) {
          this.value = new Property(null, options.value);
        } // for object type


        if (options.props) {
          this.props = [];
          ref1 = options.props;

          for (name in ref1) {
            if (!hasProp.call(ref1, name)) continue;
            prop = ref1[name];
            this.props.push(new Property(name, prop));
          }
        }
      }

      _createClass(Property, [{
        key: "validate",
        value: function validate(protocol, object, name, propPath) {
          var i, item, j, k, len, len1, prop, ref, type, value;
          name = this.name || name;

          if (this.required || Object.hasOwnProperty.call(object, name)) {
            value = object[name];
            type = Tools.typeOf(value);

            if (propPath) {
              if (Tools.isNumber(name)) {
                propPath += "[".concat(name, "]");
              } else {
                propPath += ".".concat(name);
              }
            } else {
              propPath = name;
            } // if @type.Key
            //     if type isnt 'String'
            //         protocol.throw "Key property type validation fail. Property: '#{propPath}'. Expected type: 'String'. Got type: '#{type}'."
            //     console.log 'Key:', value, propPath


            if (this.type[type] !== true) {
              types = Object.keys(this.type).join(', ');
              protocol.throw("Request property type validation fail. Property: '".concat(propPath, "'. Expected types: '").concat(types, "'. Got type: '").concat(type, "'."));
            }

            if (this.value && type === 'Array') {
              for (i = j = 0, len = value.length; j < len; i = ++j) {
                item = value[i];
                this.value.validate(protocol, value, i, propPath);
              }
            }

            if (this.props && type === 'Object') {
              ref = this.props;

              for (k = 0, len1 = ref.length; k < len1; k++) {
                prop = ref[k];
                prop.validate(protocol, value, null, propPath);
              }
            }
          }

          return this;
        }
      }]);

      return Property;
    }();

    Model.Property = Property;
    return Model;
  }.call(this);

  ReqsRequest = function ReqsRequest(type1) {
    "use strict";

    _classCallCheck(this, ReqsRequest);

    this.type = type1;
  }; // args = [ a...n ] - method argument list,
  // each argument can be callback function presented as string 'callback ID'
  // cbs = 'callbacks list' [ num_0...num_n ], callbacks postions in arguments list
  // OR
  // id = callback ID


  ReqsMethod =
  /*#__PURE__*/
  function (_ReqsRequest) {
    "use strict";

    _inherits(ReqsMethod, _ReqsRequest);

    /*
    @class
    @param {string} method — method name
    @param {array} [args] — arguments list
    @param {array} [cbs] — list of callbacks positions in arguments list (argument - callback ID).
    @param {string} [id] — callback ID, if id is ommited - response is ommited too.
    'Id' is used when sender want to get returned value of calling method.
    'cbs' is used when sender client function was called with callbacks in arguments.
    This logic allow to have several responses to one call - as callback and as returned value.
    */
    function ReqsMethod(method, id, args, cbs) {
      var _this;

      _classCallCheck(this, ReqsMethod);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ReqsMethod).call(this, types.method));
      _this.method = method;

      if (id) {
        _this.id = id;
      }

      if (args) {
        _this.args = args;
      }

      if (cbs) {
        _this.cbs = cbs;
      }

      return _this;
    }

    return ReqsMethod;
  }(ReqsRequest);

  ReqsCallback =
  /*#__PURE__*/
  function (_ReqsRequest2) {
    "use strict";

    _inherits(ReqsCallback, _ReqsRequest2);

    /*
    @class
    @param {string} id — callback's ID: this is result of method or callback executing
    @param {array} [args] — arguments list
    @param {array} [cbs] — callbacks positions in arguments (value - callback ID)
    */
    function ReqsCallback(id1, args, cbs) {
      var _this2;

      _classCallCheck(this, ReqsCallback);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ReqsCallback).call(this, types.callback));
      _this2.id = id1;

      if (args) {
        _this2.args = args;
      }

      if (cbs) {
        _this2.cbs = cbs;
      }

      return _this2;
    }

    return ReqsCallback;
  }(ReqsRequest);

  ReqsResolve =
  /*#__PURE__*/
  function (_ReqsRequest3) {
    "use strict";

    _inherits(ReqsResolve, _ReqsRequest3);

    /*
    @class
    @param {string} id — callback's ID: this is result of method or callback executing
    @param {object} resolve — result
    */
    function ReqsResolve(id1, resolve) {
      var _this3;

      _classCallCheck(this, ReqsResolve);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ReqsResolve).call(this, types.resolve));
      _this3.id = id1;
      _this3.resolve = resolve;
      return _this3;
    }

    return ReqsResolve;
  }(ReqsRequest);

  ReqsReject =
  /*#__PURE__*/
  function (_ReqsRequest4) {
    "use strict";

    _inherits(ReqsReject, _ReqsRequest4);

    /*
    @class
    @param {string} id — callback's ID: this is result of method or callback executing
    @param {object} reject — result
    */
    function ReqsReject(id1, reject) {
      var _this4;

      _classCallCheck(this, ReqsReject);

      _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ReqsReject).call(this, types.reject));
      _this4.id = id1;
      _this4.reject = reject;
      return _this4;
    }

    return ReqsReject;
  }(ReqsRequest);

  ReqsError =
  /*#__PURE__*/
  function (_ReqsRequest5) {
    "use strict";

    _inherits(ReqsError, _ReqsRequest5);

    function ReqsError() {
      var _this5;

      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var id = arguments.length > 2 ? arguments[2] : undefined;

      _classCallCheck(this, ReqsError);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(ReqsError).call(this, types.error));
      _this5.message = message;
      _this5.code = code;

      if (id) {
        _this5.id = id;
      }

      return _this5;
    }

    return ReqsError;
  }(ReqsRequest);

  ReqsInfo =
  /*#__PURE__*/
  function (_ReqsRequest6) {
    "use strict";

    _inherits(ReqsInfo, _ReqsRequest6);

    /*
    @class
    @param {string} id — callback's ID: this is result of method or callback executing
    @param {string[]} [events] — list of events (for client's api)
    @param {string[]} [methods] — list of methods (for client's api)
    */
    function ReqsInfo(id1, events, methods) {
      var _this6;

      _classCallCheck(this, ReqsInfo);

      _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ReqsInfo).call(this, types.info));
      _this6.id = id1;

      if (events) {
        _this6.events = events;
      }

      if (methods) {
        _this6.methods = methods;
      }

      return _this6;
    }

    return ReqsInfo;
  }(ReqsRequest);

  Protocol = function () {
    var Protocol =
    /*#__PURE__*/
    function () {
      "use strict";

      function Protocol() {
        var options1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Protocol);

        this.options = options1;
        this.model = {
          request: new Model({
            type: Model.required('Number')
          }),
          method: new Model({
            method: Model.required('String'),
            id: 'String',
            args: 'Array',
            cbs: 'Array'
          }),
          callback: new Model({
            id: Model.required('String'),
            args: 'Array',
            cbs: 'Array'
          }),
          promise: new Model({
            id: Model.required('String')
          }),
          error: new Model({
            message: Model.required('String'),
            code: 'Number',
            id: 'String'
          }),
          info: new Model({
            id: Model.required('String'),
            events: 'Array',
            methods: 'Array'
          })
        };
      }

      _createClass(Protocol, [{
        key: "throw",
        value: function _throw(msg) {
          throw new Error("Protocol processing error: ".concat(msg));
        } // Request parsing and validation

      }, {
        key: "parse",
        value: function parse(request) {
          var r;
          this.model.request.validate(this, request);

          switch (request.type) {
            case types.method:
              this.model.method.validate(this, request);
              r = new ReqsMethod(request.method, request.id, request.args, request.cbs);
              break;

            case types.callback:
              this.model.callback.validate(this, request);
              r = new ReqsCallback(request.id, request.args, request.cbs);
              break;

            case types.resolve:
              this.model.promise.validate(this, request);
              r = new ReqsResolve(request.id, request.resolve);
              break;

            case types.reject:
              this.model.promise.validate(this, request);
              r = new ReqsReject(request.id, request.reject);
              break;

            case types.error:
              this.model.error.validate(this, request);
              r = new ReqsError(request.message, request.code, request.id);
              break;

            case types.info:
              this.model.info.validate(this, request);
              r = new ReqsInfo(request.id, request.events, request.methods);
              break;

            default:
              r = this.throw("Unknown request type: ".concat(request.type));
          }

          return r;
        }
      }]);

      return Protocol;
    }();

    ;
    Protocol.category = 'protocols';
    Protocol.option = 'coder';
    Protocol.types = types;
    Protocol.prototype.types = types;
    Protocol.Model = Model; // Request creation constructors (executes in Protocol's context)

    /*
    Create method request, constructor
    @class
    @param {string} methodName — method name
    @param {string} id — id of the request
    @param {array} arguments — method arguments
    @param {array} cbs — callbacks ID positions in arguments
    @return {object} request — builded request
    */

    Protocol.prototype.Method = ReqsMethod;
    Protocol.Method = ReqsMethod;
    /*
    Create callback request, constructor
    @class
    @param {string} id — id of the request
    @param {array} arguments — callback arguments
    @param {array} cbs — callbacks ID positions in arguments
    @return {object} request — builded request
    */

    Protocol.prototype.Callback = ReqsCallback;
    Protocol.Callback = ReqsCallback;
    /*
    Create promise resolve request, constructor
    @class
    @param {string} id — id of the request
    @param {object} result — result object
    @return {object} request — builded request
    */

    Protocol.prototype.Resolve = ReqsResolve;
    Protocol.Resolve = ReqsResolve;
    /*
    Create promise reject request, constructor
    @class
    @param {string} id — id of the request
    @param {object} reject — reject object
    @return {object} request — builded request
    */

    Protocol.prototype.Reject = ReqsReject;
    Protocol.Reject = ReqsReject;
    /*
    Create error request, constructor
    @class
    @param {string} message — error message
    @param {number} code — error code
    @param {string} id — id of the request
    @return {object} request — builded request
    */

    Protocol.prototype.Error = ReqsError;
    Protocol.Error = ReqsError;
    /*
    Create info request, constructor
    @class
    @param {string} id — id of the request
    @param {array} events — server's events list (methods at client side)
    @param {array} methods — server's methods list (events at client side)
    @return {object} request — builded request
    */

    Protocol.prototype.Info = ReqsInfo;
    Protocol.Info = ReqsInfo;
    return Protocol;
  }.call(this); // Generated by CoffeeScript 2.5.1


  var Tools;

  Tools = function () {
    var isArr, t;

    var Tools =
    /*#__PURE__*/
    function () {
      "use strict";

      function Tools() {
        _classCallCheck(this, Tools);
      }

      _createClass(Tools, null, [{
        key: "isBoolean",
        value: function isBoolean(v) {
          return t.call(v) === '[object Boolean]';
        }
      }, {
        key: "isString",
        value: function isString(v) {
          return t.call(v) === '[object String]';
        }
      }, {
        key: "isObject",
        value: function isObject(v) {
          return t.call(v) === '[object Object]';
        }
      }, {
        key: "isFunction",
        value: function isFunction(v) {
          return t.call(v) === '[object Function]';
        }
      }, {
        key: "isNumber",
        value: function isNumber(v) {
          return v === v && t.call(v) === '[object Number]'; // NaN === NaN -> false
        }
      }, {
        key: "typeOf",
        value: function typeOf(v) {
          return t.call(v).slice(8, -1); // Attention! typeOf(NaN) === 'Number'
        }
      }, {
        key: "null",
        value: function _null(o) {
          return Object.assign(Object.create(null), o);
        }
      }]);

      return Tools;
    }();

    ;
    t = Object.prototype.toString;
    isArr = Array.isArray; // @isArray:       (v) -> isArr v                                      # t.call(v) is '[object Array]'

    Tools.isArray = Array.isArray;
    return Tools;
  }.call(this); // @isBoolean.type = 'Boolean'
  // @isString.type = 'String'
  // @isArray.type = 'Array'         # <- Reason of wrapping of Array.isArray
  // @isObject.type = 'Object'
  // @isFunction.type = 'Function'
  // @isNumber.type = 'Number'
  // Generated by CoffeeScript 2.5.1

  /*
  Reqs class
  @class
  */


  var Reqs,
      hasProp = {}.hasOwnProperty;

  Reqs = function () {
    var argsConvertCb2Id, argsConvertId2Cb, callbackRequest;

    var Reqs =
    /*#__PURE__*/
    function () {
      "use strict";

      // ################### #
      // --- Constructor --- #
      // ################### #

      /*
      Create Reqs API instance
      @constructor
      @param {object} options
      */
      function Reqs() {
        var _this7 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Reqs);

        var coder, coderArgs, f, name, protocol, protocolArgs, ref, sArgs;
        this.events = Tools.null();
        this.methods = Tools.null();
        this.isSession = false;
        this._callbacks = Tools.null(); // Callbacks container

        this._id = 0; // Callbacks counter

        this._promises = Tools.null(); // Promises xt container

        this._pid = 0; // Promises counter
        // Adding events handlers

        if (options.events) {
          ref = options.events;

          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            f = ref[name];
            this.events[name] = f;
          }
        } // Adding methods


        if (options.methods) {
          this.addMethods(options.methods);
        } // Saving some options for inheritance
        // when session will be created


        this.options = {
          methods: options.methods || {},
          session: options.session
        }; // Setting send function

        if (options.send) {
          this.send = options.send;
        } // Processing error options


        if (options.error) {
          this.error = options.error;
        } // ID Generators


        if (options.newid) {
          this.newid = options.newid;
        }

        if (options.newpid) {
          this.newpid = options.newpid;
        } // Set coder


        coderArgs = options.key ? [options.key] : [];

        if (options.coder) {
          if (Tools.isString(options.coder)) {
            coder = Reqs.coders[options.coder];
          } else {
            coder = Reqs.coders[options.coder.name || Reqs.default.coder];

            if (options.coder.arguments) {
              coderArgs = options.coder.arguments;
            }
          }

          if (!coder) {
            throw new Error("Unknown coder: '".concat(options.coder, "'"));
          }
        } else {
          coder = Reqs.coders[Reqs.default.coder];
        }

        this.coder = _construct(coder, _toConsumableArray(coderArgs)); // Set protocol

        protocolArgs = [];

        if (options.protocol) {
          if (Tools.isString(options.protocol)) {
            protocol = Reqs.protocols[options.protocol];
          } else {
            protocol = Reqs.protocols[options.protocol.name || Reqs.default.protocol];

            if (options.protocol.arguments) {
              protocolArgs = options.protocol.arguments;
            }
          }

          if (!protocol) {
            throw new Error("Unknown protocol: '".concat(options.protocol, "'"));
          }
        } else {
          protocol = Reqs.protocols[Reqs.default.protocol];
        }

        this.protocol = _construct(protocol, _toConsumableArray(protocolArgs)); // Processing session options

        if (options.session) {
          // Save custom arguments names
          sArgs = options.session.arguments;

          if (Tools.isString(sArgs)) {
            this.options.session.arguments = [sArgs];
          } else if (Tools.isArray(sArgs)) {
            this.options.session.arguments = sArgs;
          }
        } else {
          this.options.session = {
            arguments: []
          };
        }

        Object.defineProperty(this, 'async', {
          get: function get() {
            return _this7._async;
          },
          set: function set(value) {
            return _this7.asyncSet(value);
          }
        });
        this.async = Tools.isBoolean(options.mode) ? options.mode === 'async' : Reqs.default.mode === 'async';
      } // #################### #
      // --- Main methods --- #
      // #################### #

      /*
      Parse the request data.
      @param {string} request — the string/buffer/whatever from client/server
      (allow to transfer any user data from data input point to API functions)
      @return {object} result — result of API call (can be undefined or null)
      */


      _createClass(Reqs, [{
        key: "parse",
        value: function parse(data) {
          var decodedData, e, j, len, request, result;

          try {
            decodedData = this.coder.decode(data);
          } catch (error) {
            e = error;
            return this.err400("Data processing error: ".concat(e.message, "\n").concat(e.stack));
          }

          try {
            if (Tools.isArray(decodedData)) {
              for (j = 0, len = decodedData.length; j < len; j++) {
                request = decodedData[j];
                result = this.processRequest(request);
              }
            } else {
              result = this.processRequest(decodedData);
            }
          } catch (error) {
            e = error;
            return this.err400("Request parsing error: ".concat(e.message, "\n").concat(e.stack));
          }

          return result;
        }
      }, {
        key: "processRequest",
        value: function processRequest(data) {
          var _this8 = this;

          var args, e, id, method, promiseXt, protocol, request, response, result, types, xt;
          request = this.protocol.parse(data);
          protocol = this.protocol;
          types = protocol.types;
          id = request.id;

          switch (request.type) {
            // ##################################################
            // API Method handling
            case types.method:
              method = request.method;
              xt = this.events[method];

              if (xt) {
                args = argsConvertId2Cb(this, request.args, request.cbs);

                if (id) {
                  // This request was created with promise (async mode)
                  // Normal processing
                  try {
                    result = xt.apply(this, args);

                    if (result instanceof Promise) {
                      result.then(function (promiseResult) {
                        return _this8.request(new protocol.Resolve(id, promiseResult));
                      }).catch(function (promiseErr) {
                        return _this8.request(new protocol.Reject(id, promiseErr.toString()));
                      });
                      return result;
                    } else {
                      response = new protocol.Resolve(id, result);
                    }
                  } catch (error) {
                    e = error; // Errors processing

                    response = new protocol.Reject(id, e.toString());
                  }

                  return this.request(response); // Client/server don't want result (or, callbacks is used) (sync mode)
                } else {
                  return xt.apply(this, args);
                }
              } else {
                return this.err404("Method not found: <".concat(method, ">."));
              }

              break;
            // ##################################################
            // Callback handling

            case types.callback:
              xt = this._callbacks[id];

              if (xt === void 0) {
                return this.err404("Wrong callback ID: <".concat(id, ">."));
              }

              delete this._callbacks[id];
              args = argsConvertId2Cb(this, request.args, request.cbs);
              return xt.apply(this, args || []);

            case types.resolve:
              promiseXt = this._promises[id];
              delete this._promises[id];

              if (promiseXt && promiseXt.resolve) {
                return promiseXt.resolve.call(this, request.resolve);
              } else {
                return this.err404("Wrong resolve promise ID: <".concat(id, ">."));
              }

              break;

            case types.reject:
              promiseXt = this._promises[id];
              delete this._promises[id];

              if (promiseXt && promiseXt.reject) {
                return promiseXt.reject.call(this, request.reject);
              } else {
                return this.err404("Wrong reject promise ID: <".concat(id, ">."));
              }

              break;

            case types.info:
              if (id) {
                // TODO: add full details sending
                return this.request(new protocol.Callback(id, [Object.keys(this.methods), // -> events for connected client
                Object.keys(this.events) // -> methods for connected client
                ]));
              }

              break;

            case types.error:
              return this.err422("Error request. Code: '".concat(request.code, "'. ").concat(request.message));

            default:
              return this.err422("Unknown request type: '".concat(request.type, "'."));
          }

          return null;
        }
        /*
        Encode and send request
        @param {object} request — request object
        */

      }, {
        key: "request",
        value: function request(_request) {
          return this.send(this.coder.encode(_request));
        } // ############################## #
        // --- Error handling methods --- #
        // ############################## #

        /*
        Error 'Input data decoding error or wrong input data'
        @param {string} message — error message
        */

      }, {
        key: "err400",
        value: function err400(message) {
          return this.error(message, 400);
        }
        /*
        Error 'API Method or callback not found'
        @param {string} message — error message
        */

      }, {
        key: "err404",
        value: function err404(message) {
          return this.error(message, 404);
        }
        /*
        Error 'Wrong data input'
        @param {string} message — error message
        */

      }, {
        key: "err422",
        value: function err422(message) {
          return this.error(message, 422);
        }
        /*
        Error rised during processing request
        @param {number} code — error code
        @param {string} message — error message
        */

      }, {
        key: "error",
        value: function error(message, code) {
          return console.warn(code, message);
        }
        /*
        Send error message to client/server
        @param {string} id — request id
        @param {number} code — error code
        @param {string} message — error message
        */

      }, {
        key: "sendError",
        value: function sendError(message, code, id) {
          return this.request(new this.protocol.Error(message, code, id));
        } // ########################## #
        // --- Options in runtime --- #
        // ########################## #

        /*
        Set method's executing mode: async or sync
        @param {boolean} value — async or sync mode
        */

      }, {
        key: "asyncSet",
        value: function asyncSet(value) {
          this._async = value;
          this.methodApply = value ? this.methodAsyncApply : this.methodSyncApply;
        }
        /*
        Set coder by name
        @param {string} coder — coder name
        */

      }, {
        key: "coderSet",
        value: function coderSet(coder) {
          return this.coder = Reqs.coders[coder];
        }
        /*
        Set protocol by name
        @param {string} protocol — protocol name
        */

      }, {
        key: "protocolSet",
        value: function protocolSet(protocol) {
          return this.protocol = Reqs.protocols[protocol];
        }
        /*
        Use module
        @param {Class} module — module to use
        */

      }, {
        key: "use",
        value: function use(module) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return this[module.option] = _construct(module, args);
        } // ################################## #
        // --- Callbacks handling methods --- #
        // ################################## #

        /*
        Create callback function with cached ID and session and return it.
        @param {string} id — ID of callback
        @return {function} xt — function with cached id and current Reqs API session
        */

      }, {
        key: "createCallback",
        value: function createCallback(id) {
          var api, newCb;
          api = this;

          newCb = function newCb() {
            return callbackRequest(api, id, arguments);
          };

          newCb.created = Date.now(); // Callback creation time - required for callbacks dispose in runtime

          return newCb;
        }
        /*
        Generate new ID for callback or promise.
        @return {string} id — callback ID as string
        */

      }, {
        key: "newid",
        value: function newid() {
          if (this._id === Number.MAX_SAFE_INTEGER) {
            this._id = 0;
          }

          return (++this._id).toString();
        }
        /*
        Generate new promise ID for async request.
        @return {string} id — promise ID as string
        */

      }, {
        key: "newpid",
        value: function newpid() {
          if (this._pid === Number.MAX_SAFE_INTEGER) {
            this._pid = 0;
          }

          return (++this._pid).toString();
        }
        /*
        Add callback and return it's ID. By default ID is a simple counter.
        Callbacks starts from 1 and up to Number.MAX_SAFE_INTEGER.
        Transfers as a string for case if server/client can have
        Number.MAX_SAFE_INTEGER less, then client/server and custom ID generators.
        @param {function} cb — callback function
        @return {string} id — callback's ID
        */

      }, {
        key: "addCallback",
        value: function addCallback(cb) {
          var id;
          id = this.newid();
          this._callbacks[id] = cb;
          return id;
        }
        /*
        Call method with next arguments.
        Mode (async/sync) depends on this.async flag.
        @param {string} method — method name
        @param {object} ...args — arguments
        */

      }, {
        key: "method",
        value: function method(_method) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return this.methodApply(_method, args);
        }
        /*
        Call method asynchronously with next arguments
        @param {string} method — method name
        @param {object} ...args — arguments
        */

      }, {
        key: "methodAsync",
        value: function methodAsync(method) {
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          return this.methodAsyncApply(method, args);
        }
        /*
        Call method synchronously with next arguments
        @param {string} method — method name
        @param {object} ...args — arguments
        */

      }, {
        key: "methodSync",
        value: function methodSync(method) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return this.methodSyncApply(method, args);
        }
        /*
        Apply method asynchronously with arguments
        @param {string} method — method name
        @param {arrayLike} args — arguments array-like object (arguments)
        @param {array} args — arguments array
        */

      }, {
        key: "methodAsyncApply",
        value: function methodAsyncApply(method, args) {
          var _this9 = this;

          var cbs, convertedArgs, pid, promise;

          var _argsConvertCb2Id = argsConvertCb2Id(this, args);

          var _argsConvertCb2Id2 = _slicedToArray(_argsConvertCb2Id, 2);

          convertedArgs = _argsConvertCb2Id2[0];
          cbs = _argsConvertCb2Id2[1];
          pid = this.newpid();
          promise = new Promise(function (resolve, reject) {
            return _this9._promises[pid] = {
              resolve: resolve,
              reject: reject
            };
          });
          this.request(new this.protocol.Method(method, pid, convertedArgs, cbs)); // Request sending

          return promise;
        }
        /*
        Apply method synchronously with arguments
        @param {string} method — method name
        @param {arrayLike} args — arguments array-like object (arguments)
        @param {array} args — arguments array
        */

      }, {
        key: "methodSyncApply",
        value: function methodSyncApply(method, args) {
          var cbs, convertedArgs;

          var _argsConvertCb2Id3 = argsConvertCb2Id(this, args);

          var _argsConvertCb2Id4 = _slicedToArray(_argsConvertCb2Id3, 2);

          convertedArgs = _argsConvertCb2Id4[0];
          cbs = _argsConvertCb2Id4[1];
          return this.request(new this.protocol.Method(method, null, convertedArgs, cbs)); // Request sending
        }
        /*
        Create function-wrapper for API calls.
        Usefull for data preprocessing before send.
        Arguments of xt will be sended to client/server directly.
        Session and method's name is cahced.
        @param {string} method — method's name, will be cached
        @return {object} this
        */

      }, {
        key: "addMethod",
        value: function addMethod(method) {
          var api;
          api = this;

          this.methods[method] = function () {
            return api.methodApply(method, arguments);
          };

          return this;
        }
        /*
        Create function-wrapper for API calls for selected function.
        Allow to prepare arguments or callback for server.
        Session and name is cahced.
        @param {string} functionName — function name, will be cached
        @param {function} xt — function, will be called before request sending
        @param {function} xtThen — function, attached to promise via 'then' method
        @param {function} xtCatch — function, attached to promise via 'catch' method
        @return {object} this
        */

      }, {
        key: "createMethod",
        value: function createMethod(method, xt, mode, xtThen, xtCatch) {
          var safe = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
          var api, methods, mxt;
          api = this;
          methods = this.methods;

          if (safe && methods[method]) {
            return;
          }

          if (mode === void 0) {
            if (xt) {
              methods[method] = function () {
                return api.methodApply(method, xt.apply(api, arguments));
              };
            } else {
              methods[method] = function () {
                return api.methodApply(method, arguments);
              };
            }
          } else if (mode === 'async') {
            if (xtThen && xtCatch) {
              mxt = xt ? function () {
                return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen).catch(xtCatch);
              } : function () {
                return api.methodAsyncApply(method, arguments).then(xtThen).catch(xtCatch);
              };
            } else if (xtThen) {
              mxt = xt ? function () {
                return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen);
              } : function () {
                return api.methodAsyncApply(method, arguments).then(xtThen);
              };
            } else if (xtCatch) {
              mxt = xt ? function () {
                return api.methodAsyncApply(method, xt.apply(api, arguments)).catch(xtCatch);
              } : function () {
                return api.methodAsyncApply(method, arguments).catch(xtCatch);
              };
            } else {
              mxt = xt ? function () {
                return api.methodAsyncApply(method, xt.apply(api, arguments));
              } : function () {
                return api.methodAsyncApply(method, arguments);
              };
            }

            methods[method] = mxt;
          } else {
            methods[method] = xt ? function () {
              return api.methodSyncApply(method, xt.apply(api, arguments));
            } : function () {
              return api.methodSyncApply(method, arguments);
            };
          }

          return this;
        }
        /*
        Create API methods. Basically just wrap function into another function
        with cached context (API instance or session) and method name.
        @param {array} methodsList — string array with function names
        @param {object} methodsList — object with functions for data preprocessing
        @param {safe} safe — do not overwrite existsing methods (true by default)
        @return {object} this
        */

      }, {
        key: "addMethods",
        value: function addMethods(methodsList, safe) {
          var j, len, m, method, methods, name;
          methods = this.methods;

          if (Tools.isArray(methodsList)) {
            for (j = 0, len = methodsList.length; j < len; j++) {
              method = methodsList[j];

              if (Tools.isString(method)) {
                if (methods[method]) {
                  continue;
                }

                this.addMethod(method);
              } else if (Tools.isObject(method)) {
                for (name in method) {
                  if (!hasProp.call(method, name)) continue;
                  m = method[name];

                  if (methods[name]) {
                    continue;
                  }

                  if (Tools.isFunction(m)) {
                    this.createMethod(name, m, null, null, null, safe);
                  } else {
                    this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
                  }
                }
              }
            }
          } else if (Tools.isObject(methodsList)) {
            for (name in methodsList) {
              if (!hasProp.call(methodsList, name)) continue;
              m = methodsList[name];

              if (methods[name]) {
                continue;
              }

              if (Tools.isFunction(m)) {
                this.createMethod(name, m, null, null, null, safe);
              } else {
                this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
              }
            }
          }

          return this;
        }
        /*
        Get info about server's API
        @param {string} [methodName] — methodName
        @param {function} cb — callback for result processing
        @return {object}
        */

      }, {
        key: "info",
        value: function info(cb) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var id;

          if (!Tools.isFunction(cb)) {
            throw new Error('Reqs.info() call without callback for data.');
          } // @request INFO: methodName, CB: @addCallback cb


          id = this.addCallback(cb);
          return this.request(new this.protocol.Info(id, options.events, options.methods));
        }
        /*
        Collect server's API methods list and create local client API methods
        @param {function} cb — callback
        @return {object} this
        */

      }, {
        key: "build",
        value: function build(cb) {
          var _this10 = this;

          this.info(function (events, methods) {
            _this10.addMethods(methods);

            if (Tools.isFunction(cb)) {
              return cb(events, methods);
            }
          });
          return this;
        } // ########################## #
        // --- Modules management --- #
        // ########################## #

      }, {
        key: "new",
        // ########################### #
        // --- Sessions management --- #
        // ########################### #

        /*
        Create new session (child for current Reqs API)
        @param {object} [context][arg_1...arg_n] — user-defined argument
        or arguments for adding to session object as properties.
        If options.session.arguments is empty, then first argument will be
        saved to <Session>.context property.
        If options.session.arguments array is defined, then will be used
        this list of arguments names for defining the properties of session.
        @return {Session} session — session instance nested from Reqs API instance.
        */
        value: function _new() {
          var i, j, len, prop, ref, session; // Check for correct session creation: session must be
          // inherited from Reqs API instance, not from session.

          if (this.isSession) {
            throw new Error('<Reqs.Session instance>.new() used for new session creation. Use insted "<Reqs instance>.new()".');
          } // Creating of session instance nested from current Reqs API


          session = Object.create(this); // Adding user-defined properties

          if (arguments.length > 0) {
            ref = this.options.session.arguments;

            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              prop = ref[i];
              session[prop] = arguments[i];
            }
          } // Setting session properties


          session.isSession = true; // Is this object is session

          session.created = Date.now(); // Session creation date

          session.reqs = this; // Parent Reqs API instance

          session._callbacks = Tools.null(); // This session callbacks list

          session._id = 0; // Callbacks ID counter

          session._promises = Tools.null();
          session._pid = 0;
          session.methods = Tools.null(); // Session client API functions

          session.addMethods(this.options.methods); // Methods creation (required for caching session)

          return session;
        }
      }], [{
        key: "addModule",
        value: function addModule(m) {
          var modulesContainer;
          modulesContainer = this[m.category];

          if (!modulesContainer) {
            modulesContainer = this[m.category] = Tools.null();
          }

          modulesContainer[m.name] = m;
          return m;
        }
      }]);

      return Reqs;
    }();

    ; // ####################### #
    // --- Default options --- #
    // ####################### #
    // Is methods async (returns promise) or not (returns options.send result)

    Reqs.default = {
      mode: 'sync',
      coder: 'Coder',
      protocol: 'Protocol'
    }; // ############### #
    // --- Modules --- #
    // ############### #

    Reqs.protocols = Tools.null({
      Protocol: Protocol
    });
    Reqs.coders = Tools.null({
      Coder: Coder
    }); // ############################## #
    // --- Tools and constructors --- #
    // ############################## #

    Reqs.Tools = Tools;
    Reqs.Protocol = Protocol;
    Reqs.Coder = Coder;
    /*
    Send compiled request to server/client.
    @param {string} data — data for sending (default: JSON string)
    */

    Reqs.prototype.send = console.info; // ###################################### #
    // --- Callbacks arguments converters --- #
    // ###################################### #

    argsConvertCb2Id = function argsConvertCb2Id(api) {
      var requestArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var arg, args, cbs, i, j, len;
      args = [];
      cbs = []; // Converting object to array

      for (i = j = 0, len = requestArgs.length; j < len; i = ++j) {
        arg = requestArgs[i];

        if (Tools.isFunction(arg)) {
          arg = api.addCallback(arg);
          cbs.push(Number.parseInt(i)); // For array-like objects 'arguments' case
        }

        args.push(arg);
      }

      if (cbs.length === 0) {
        cbs = null;
      }

      return [args, cbs];
    };

    argsConvertId2Cb = function argsConvertId2Cb(api) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var cbs = arguments.length > 2 ? arguments[2] : undefined;
      var callbackId, id, j, len;

      if (cbs === void 0 || cbs.length === 0) {
        return args;
      } // Converting object to array


      for (j = 0, len = cbs.length; j < len; j++) {
        id = cbs[j];
        callbackId = args[id];
        args[id] = api.createCallback(callbackId);
      }

      return args;
    };

    callbackRequest = function callbackRequest(api, id, cbArgs) {
      var args, cbs;

      var _argsConvertCb2Id5 = argsConvertCb2Id(api, cbArgs);

      var _argsConvertCb2Id6 = _slicedToArray(_argsConvertCb2Id5, 2);

      args = _argsConvertCb2Id6[0];
      cbs = _argsConvertCb2Id6[1];
      return api.request(new api.protocol.Callback(id, args, cbs)); // Request sending
    };

    return Reqs;
  }.call(this);

  module.exports = Reqs;
  ;
  return module.exports;
}(this.module || {});