this.Reqs=(function(module){// Generated by CoffeeScript 2.5.1
var Coder;

Coder = (function() {
  class Coder {
    encodeKey(request) {
      request.key = this.key;
      return JSON.stringify(request);
    }

    decodeKey(data) {
      var request;
      request = JSON.parse(data);
      if (request.key !== this.key) {
        throw new Error("Wrong API Key");
      }
      delete request.key;
      return request;
    }

    constructor(key) {
      if (key) {
        this.key = key;
        this.encode = this.encodeKey;
        this.decode = this.decodeKey;
      }
    }

  };

  Coder.category = 'coders';

  Coder.option = 'coder';

  /*
  Default encode function from object to data
  @param {object} object — object with request
  @return {string} data — output data; object, encoded to string/buffer/whatever format
  */
  Coder.prototype.encode = JSON.stringify;

  /*
  Default decode function from data to object
  @param {string} data — input request in string/buffer/whatever format
  @return {object} object — decoded object from data
  */
  Coder.prototype.decode = JSON.parse;

  return Coder;

}).call(this);

//# sourceMappingURL=Coder.js.map

// Generated by CoffeeScript 2.5.1
  // Base classes for all requests types.
  // 1. For requests creation from incoming data
  // 2. Default data type for sending

// Requests types
var Model, Protocol, ReqsCallback, ReqsError, ReqsInfo, ReqsMethod, ReqsReject, ReqsRequest, ReqsResolve, types,
  hasProp = {}.hasOwnProperty;

types = {
  none: 0,
  method: 1,
  callback: 2,
  resolve: 3,
  reject: 4,
  error: 5,
  info: 6,
  0: 'none',
  1: 'method',
  2: 'callback',
  3: 'resolve',
  4: 'reject',
  5: 'error',
  6: 'info'
};

Model = (function() {
  var Property;

  class Model {
    constructor(props) {
      var name, prop;
      this.props = [];
      for (name in props) {
        if (!hasProp.call(props, name)) continue;
        prop = props[name];
        this.props.push(new Property(name, prop));
      }
    }

    validate(protocol, object) {
      var j, len, prop, ref;
      ref = this.props;
      for (j = 0, len = ref.length; j < len; j++) {
        prop = ref[j];
        prop.validate(protocol, object);
      }
      return this;
    }

    static required(type, props = {}) {
      return Object.assign(props, {
        type: type,
        required: true
      });
    }

  };

  Property = class Property {
    /*
    @class
    @param {string} name — property name
    @param {string} optionsOrType — property type
    @param {object} optionsOrType — property options:
        {array} types — list of allowed property types
        {boolean} [required] — is property required in object or not
        {object} [value] — value property for Array type value
        {object} [props] — properties for object type
    */
    constructor(name1, optionsOrType) {
      var j, len, name, options, prop, ref, ref1, t;
      this.name = name1;
      if (Tools.isString(optionsOrType)) {
        options = {
          type: [optionsOrType]
        };
      } else {
        options = optionsOrType;
        if (Tools.isString(options.type)) {
          options.type = [options.type];
        }
      }
      this.type = Tools.null();
      ref = options.type;
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        this.type[t] = true;
      }
      this.required = options.required !== void 0 ? options.required : false;
      // for array type
      if (options.value) {
        this.value = new Property(null, options.value);
      }
      // for object type
      if (options.props) {
        this.props = [];
        ref1 = options.props;
        for (name in ref1) {
          if (!hasProp.call(ref1, name)) continue;
          prop = ref1[name];
          this.props.push(new Property(name, prop));
        }
      }
    }

    validate(protocol, object, name, propPath) {
      var i, item, j, k, len, len1, prop, ref, type, value;
      name = this.name || name;
      if (this.required || Object.hasOwnProperty.call(object, name)) {
        value = object[name];
        type = Tools.typeOf(value);
        if (propPath) {
          if (Tools.isNumber(name)) {
            propPath += `[${name}]`;
          } else {
            propPath += `.${name}`;
          }
        } else {
          propPath = name;
        }
        // if @type.Key
        //     if type isnt 'String'
        //         protocol.throw "Key property type validation fail. Property: '#{propPath}'. Expected type: 'String'. Got type: '#{type}'."
        //     console.log 'Key:', value, propPath
        if (this.type[type] !== true) {
          types = Object.keys(this.type).join(', ');
          protocol.throw(`Request property type validation fail. Property: '${propPath}'. Expected types: '${types}'. Got type: '${type}'.`);
        }
        if (this.value && type === 'Array') {
          for (i = j = 0, len = value.length; j < len; i = ++j) {
            item = value[i];
            this.value.validate(protocol, value, i, propPath);
          }
        }
        if (this.props && type === 'Object') {
          ref = this.props;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            prop = ref[k];
            prop.validate(protocol, value, null, propPath);
          }
        }
      }
      return this;
    }

  };

  Model.Property = Property;

  return Model;

}).call(this);

ReqsRequest = class ReqsRequest {
  constructor(type1) {
    this.type = type1;
  }

};

// args = [ a...n ] - method argument list,
// each argument can be callback function presented as string 'callback ID'
// cbs = 'callbacks list' [ num_0...num_n ], callbacks postions in arguments list
// OR
// id = callback ID
ReqsMethod = class ReqsMethod extends ReqsRequest {
  /*
  @class
  @param {string} method — method name
  @param {array} [args] — arguments list
  @param {array} [cbs] — list of callbacks positions in arguments list (argument - callback ID).
  @param {string} [id] — callback ID, if id is ommited - response is ommited too.
  'Id' is used when sender want to get returned value of calling method.
  'cbs' is used when sender client function was called with callbacks in arguments.
  This logic allow to have several responses to one call - as callback and as returned value.
  */
  constructor(method, id, args, cbs) {
    super(types.method);
    this.method = method;
    if (id) {
      this.id = id;
    }
    if (args) {
      this.args = args;
    }
    if (cbs) {
      this.cbs = cbs;
    }
  }

};

ReqsCallback = class ReqsCallback extends ReqsRequest {
  /*
  @class
  @param {string} id — callback's ID: this is result of method or callback executing
  @param {array} [args] — arguments list
  @param {array} [cbs] — callbacks positions in arguments (value - callback ID)
  */
  constructor(id1, args, cbs) {
    super(types.callback);
    this.id = id1;
    if (args) {
      this.args = args;
    }
    if (cbs) {
      this.cbs = cbs;
    }
  }

};

ReqsResolve = class ReqsResolve extends ReqsRequest {
  /*
  @class
  @param {string} id — callback's ID: this is result of method or callback executing
  @param {object} resolve — result
  */
  constructor(id1, resolve) {
    super(types.resolve);
    this.id = id1;
    this.resolve = resolve;
  }

};

ReqsReject = class ReqsReject extends ReqsRequest {
  /*
  @class
  @param {string} id — callback's ID: this is result of method or callback executing
  @param {object} reject — result
  */
  constructor(id1, reject) {
    super(types.reject);
    this.id = id1;
    this.reject = reject;
  }

};

ReqsError = class ReqsError extends ReqsRequest {
  constructor(message = '', code = null, id) {
    super(types.error);
    this.message = message;
    this.code = code;
    if (id) {
      this.id = id;
    }
  }

};

ReqsInfo = class ReqsInfo extends ReqsRequest {
  /*
  @class
  @param {string} id — callback's ID: this is result of method or callback executing
  @param {string[]} [events] — list of events (for client's api)
  @param {string[]} [methods] — list of methods (for client's api)
  */
  constructor(id1, events, methods) {
    super(types.info);
    this.id = id1;
    if (events) {
      this.events = events;
    }
    if (methods) {
      this.methods = methods;
    }
  }

};

Protocol = (function() {
  class Protocol {
    constructor(options1 = {}) {
      this.options = options1;
      this.model = {
        request: new Model({
          type: Model.required('Number')
        }),
        method: new Model({
          method: Model.required('String'),
          id: 'String',
          args: 'Array',
          cbs: 'Array'
        }),
        callback: new Model({
          id: Model.required('String'),
          args: 'Array',
          cbs: 'Array'
        }),
        promise: new Model({
          id: Model.required('String')
        }),
        error: new Model({
          message: Model.required('String'),
          code: 'Number',
          id: 'String'
        }),
        info: new Model({
          id: Model.required('String'),
          events: 'Array',
          methods: 'Array'
        })
      };
    }

    throw(msg) {
      throw new Error(`Protocol processing error: ${msg}`);
    }

    // Request parsing and validation
    parse(request) {
      var r;
      this.model.request.validate(this, request);
      switch (request.type) {
        case types.method:
          this.model.method.validate(this, request);
          r = new ReqsMethod(request.method, request.id, request.args, request.cbs);
          break;
        case types.callback:
          this.model.callback.validate(this, request);
          r = new ReqsCallback(request.id, request.args, request.cbs);
          break;
        case types.resolve:
          this.model.promise.validate(this, request);
          r = new ReqsResolve(request.id, request.resolve);
          break;
        case types.reject:
          this.model.promise.validate(this, request);
          r = new ReqsReject(request.id, request.reject);
          break;
        case types.error:
          this.model.error.validate(this, request);
          r = new ReqsError(request.message, request.code, request.id);
          break;
        case types.info:
          this.model.info.validate(this, request);
          r = new ReqsInfo(request.id, request.events, request.methods);
          break;
        default:
          r = this.throw(`Unknown request type: ${request.type}`);
      }
      return r;
    }

  };

  Protocol.category = 'protocols';

  Protocol.option = 'coder';

  Protocol.types = types;

  Protocol.prototype.types = types;

  Protocol.Model = Model;

  // Request creation constructors (executes in Protocol's context)
  /*
  Create method request, constructor
  @class
  @param {string} methodName — method name
  @param {string} id — id of the request
  @param {array} arguments — method arguments
  @param {array} cbs — callbacks ID positions in arguments
  @return {object} request — builded request
  */
  Protocol.prototype.Method = ReqsMethod;

  Protocol.Method = ReqsMethod;

  /*
  Create callback request, constructor
  @class
  @param {string} id — id of the request
  @param {array} arguments — callback arguments
  @param {array} cbs — callbacks ID positions in arguments
  @return {object} request — builded request
  */
  Protocol.prototype.Callback = ReqsCallback;

  Protocol.Callback = ReqsCallback;

  /*
  Create promise resolve request, constructor
  @class
  @param {string} id — id of the request
  @param {object} result — result object
  @return {object} request — builded request
  */
  Protocol.prototype.Resolve = ReqsResolve;

  Protocol.Resolve = ReqsResolve;

  /*
  Create promise reject request, constructor
  @class
  @param {string} id — id of the request
  @param {object} reject — reject object
  @return {object} request — builded request
  */
  Protocol.prototype.Reject = ReqsReject;

  Protocol.Reject = ReqsReject;

  /*
  Create error request, constructor
  @class
  @param {string} message — error message
  @param {number} code — error code
  @param {string} id — id of the request
  @return {object} request — builded request
  */
  Protocol.prototype.Error = ReqsError;

  Protocol.Error = ReqsError;

  /*
  Create info request, constructor
  @class
  @param {string} id — id of the request
  @param {array} events — server's events list (methods at client side)
  @param {array} methods — server's methods list (events at client side)
  @return {object} request — builded request
  */
  Protocol.prototype.Info = ReqsInfo;

  Protocol.Info = ReqsInfo;

  return Protocol;

}).call(this);

//# sourceMappingURL=Protocol.js.map

// Generated by CoffeeScript 2.5.1
var Tools;

Tools = (function() {
  var isArr, t;

  class Tools {
    static isBoolean(v) {
      return t.call(v) === '[object Boolean]';
    }

    static isString(v) {
      return t.call(v) === '[object String]';
    }

    static isObject(v) {
      return t.call(v) === '[object Object]';
    }

    static isFunction(v) {
      return t.call(v) === '[object Function]';
    }

    static isNumber(v) {
      return v === v && (t.call(v) === '[object Number]'); // NaN === NaN -> false
    }

    static typeOf(v) {
      return t.call(v).slice(8, -1); // Attention! typeOf(NaN) === 'Number'
    }

    static null(o) {
      return Object.assign(Object.create(null), o);
    }

  };

  t = Object.prototype.toString;

  isArr = Array.isArray;

  // @isArray:       (v) -> isArr v                                      # t.call(v) is '[object Array]'
  Tools.isArray = Array.isArray;

  return Tools;

}).call(this);

// @isBoolean.type = 'Boolean'
// @isString.type = 'String'
// @isArray.type = 'Array'         # <- Reason of wrapping of Array.isArray
// @isObject.type = 'Object'
// @isFunction.type = 'Function'
// @isNumber.type = 'Number'

//# sourceMappingURL=Tools.js.map


// Generated by CoffeeScript 2.5.1
  /*
  Reqs class
  @class
  */
var Reqs,
  hasProp = {}.hasOwnProperty;

Reqs = (function() {
  var argsConvertCb2Id, argsConvertId2Cb, callbackRequest;

  class Reqs {
    // ################### #
    // --- Constructor --- #
    // ################### #
    /*
    Create Reqs API instance
    @constructor
    @param {object} options
    */
    constructor(options = {}) {
      var coder, coderArgs, f, name, protocol, protocolArgs, ref, sArgs;
      this.events = Tools.null();
      this.methods = Tools.null();
      this.isSession = false;
      this._callbacks = Tools.null(); // Callbacks container
      this._id = 0; // Callbacks counter
      this._promises = Tools.null(); // Promises xt container
      this._pid = 0; // Promises counter
      
      // Adding events handlers
      if (options.events) {
        ref = options.events;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          f = ref[name];
          this.events[name] = f;
        }
      }
      // Adding methods
      if (options.methods) {
        this.addMethods(options.methods);
      }
      // Saving some options for inheritance
      // when session will be created
      this.options = {
        methods: options.methods || {},
        session: options.session
      };
      // Setting send function
      if (options.send) {
        this.send = options.send;
      }
      // Processing error options
      if (options.error) {
        this.error = options.error;
      }
      // ID Generators
      if (options.newid) {
        this.newid = options.newid;
      }
      if (options.newpid) {
        this.newpid = options.newpid;
      }
      // Set coder
      coderArgs = options.key ? [options.key] : [];
      if (options.coder) {
        if (Tools.isString(options.coder)) {
          coder = Reqs.coders[options.coder];
        } else {
          coder = Reqs.coders[options.coder.name || Reqs.default.coder];
          if (options.coder.arguments) {
            coderArgs = options.coder.arguments;
          }
        }
        if (!coder) {
          throw new Error(`Unknown coder: '${options.coder}'`);
        }
      } else {
        coder = Reqs.coders[Reqs.default.coder];
      }
      this.coder = new coder(...coderArgs);
      // Set protocol
      protocolArgs = [];
      if (options.protocol) {
        if (Tools.isString(options.protocol)) {
          protocol = Reqs.protocols[options.protocol];
        } else {
          protocol = Reqs.protocols[options.protocol.name || Reqs.default.protocol];
          if (options.protocol.arguments) {
            protocolArgs = options.protocol.arguments;
          }
        }
        if (!protocol) {
          throw new Error(`Unknown protocol: '${options.protocol}'`);
        }
      } else {
        protocol = Reqs.protocols[Reqs.default.protocol];
      }
      this.protocol = new protocol(...protocolArgs);
      // Processing session options
      if (options.session) {
        // Save custom arguments names
        sArgs = options.session.arguments;
        if (Tools.isString(sArgs)) {
          this.options.session.arguments = [sArgs];
        } else if (Tools.isArray(sArgs)) {
          this.options.session.arguments = sArgs;
        }
      } else {
        this.options.session = {
          arguments: []
        };
      }
      Object.defineProperty(this, 'async', {
        get: () => {
          return this._async;
        },
        set: (value) => {
          return this.asyncSet(value);
        }
      });
      this.async = Tools.isBoolean(options.mode) ? options.mode === 'async' : Reqs.default.mode === 'async';
    }

    // #################### #
    // --- Main methods --- #
    // #################### #
    /*
    Parse the request data.
    @param {string} request — the string/buffer/whatever from client/server
    (allow to transfer any user data from data input point to API functions)
    @return {object} result — result of API call (can be undefined or null)
    */
    parse(data) {
      var decodedData, e, j, len, request, result;
      try {
        decodedData = this.coder.decode(data);
      } catch (error) {
        e = error;
        return this.err400(`Data processing error: ${e.message}\n${e.stack}`);
      }
      try {
        if (Tools.isArray(decodedData)) {
          for (j = 0, len = decodedData.length; j < len; j++) {
            request = decodedData[j];
            result = this.processRequest(request);
          }
        } else {
          result = this.processRequest(decodedData);
        }
      } catch (error) {
        e = error;
        return this.err400(`Request parsing error: ${e.message}\n${e.stack}`);
      }
      return result;
    }

    processRequest(data) {
      var args, e, id, method, promiseXt, protocol, request, response, result, types, xt;
      request = this.protocol.parse(data);
      protocol = this.protocol;
      types = protocol.types;
      id = request.id;
      switch (request.type) {
        // ##################################################
        // API Method handling
        case types.method:
          method = request.method;
          xt = this.events[method];
          if (xt) {
            args = argsConvertId2Cb(this, request.args, request.cbs);
            if (id) { // This request was created with promise (async mode)
              // Normal processing
              try {
                result = xt.apply(this, args);
                if (result instanceof Promise) {
                  result.then((promiseResult) => {
                    return this.request(new protocol.Resolve(id, promiseResult));
                  }).catch((promiseErr) => {
                    return this.request(new protocol.Reject(id, promiseErr.toString()));
                  });
                  return result;
                } else {
                  response = new protocol.Resolve(id, result);
                }
              } catch (error) {
                e = error; // Errors processing
                response = new protocol.Reject(id, e.toString());
              }
              return this.request(response); // Client/server don't want result (or, callbacks is used) (sync mode)
            } else {
              return xt.apply(this, args);
            }
          } else {
            return this.err404(`Method not found: <${method}>.`);
          }
          break;
        // ##################################################
        // Callback handling
        case types.callback:
          xt = this._callbacks[id];
          if (xt === void 0) {
            return this.err404(`Wrong callback ID: <${id}>.`);
          }
          delete this._callbacks[id];
          args = argsConvertId2Cb(this, request.args, request.cbs);
          return xt.apply(this, args || []);
        case types.resolve:
          promiseXt = this._promises[id];
          delete this._promises[id];
          if (promiseXt && promiseXt.resolve) {
            return promiseXt.resolve.call(this, request.resolve);
          } else {
            return this.err404(`Wrong resolve promise ID: <${id}>.`);
          }
          break;
        case types.reject:
          promiseXt = this._promises[id];
          delete this._promises[id];
          if (promiseXt && promiseXt.reject) {
            return promiseXt.reject.call(this, request.reject);
          } else {
            return this.err404(`Wrong reject promise ID: <${id}>.`);
          }
          break;
        case types.info:
          if (id) {
            // TODO: add full details sending
            return this.request(new protocol.Callback(id, [
              Object.keys(this.methods), // -> events for connected client
              Object.keys(this.events) // -> methods for connected client
            ]));
          }
          break;
        case types.error:
          return this.err422(`Error request. Code: '${request.code}'. ${request.message}`);
        default:
          return this.err422(`Unknown request type: '${request.type}'.`);
      }
      return null;
    }

    /*
    Encode and send request
    @param {object} request — request object
    */
    request(request) {
      return this.send(this.coder.encode(request));
    }

    // ############################## #
    // --- Error handling methods --- #
    // ############################## #
    /*
    Error 'Input data decoding error or wrong input data'
    @param {string} message — error message
    */
    err400(message) {
      return this.error(message, 400);
    }

    /*
    Error 'API Method or callback not found'
    @param {string} message — error message
    */
    err404(message) {
      return this.error(message, 404);
    }

    /*
    Error 'Wrong data input'
    @param {string} message — error message
    */
    err422(message) {
      return this.error(message, 422);
    }

    /*
    Error rised during processing request
    @param {number} code — error code
    @param {string} message — error message
    */
    error(message, code) {
      return console.warn(code, message);
    }

    /*
    Send error message to client/server
    @param {string} id — request id
    @param {number} code — error code
    @param {string} message — error message
    */
    sendError(message, code, id) {
      return this.request(new this.protocol.Error(message, code, id));
    }

    // ########################## #
    // --- Options in runtime --- #
    // ########################## #
    /*
    Set method's executing mode: async or sync
    @param {boolean} value — async or sync mode
    */
    asyncSet(value) {
      this._async = value;
      this.methodApply = value ? this.methodAsyncApply : this.methodSyncApply;
    }

    /*
    Set coder by name
    @param {string} coder — coder name
    */
    coderSet(coder) {
      return this.coder = Reqs.coders[coder];
    }

    /*
    Set protocol by name
    @param {string} protocol — protocol name
    */
    protocolSet(protocol) {
      return this.protocol = Reqs.protocols[protocol];
    }

    /*
    Use module
    @param {Class} module — module to use
    */
    use(module, ...args) {
      return this[module.option] = new module(...args);
    }

    // ################################## #
    // --- Callbacks handling methods --- #
    // ################################## #
    /*
    Create callback function with cached ID and session and return it.
    @param {string} id — ID of callback
    @return {function} xt — function with cached id and current Reqs API session
    */
    createCallback(id) {
      var api, newCb;
      api = this;
      newCb = function() {
        return callbackRequest(api, id, arguments);
      };
      newCb.created = Date.now(); // Callback creation time - required for callbacks dispose in runtime
      return newCb;
    }

    /*
    Generate new ID for callback or promise.
    @return {string} id — callback ID as string
    */
    newid() {
      if (this._id === Number.MAX_SAFE_INTEGER) {
        this._id = 0;
      }
      return (++this._id).toString();
    }

    /*
    Generate new promise ID for async request.
    @return {string} id — promise ID as string
    */
    newpid() {
      if (this._pid === Number.MAX_SAFE_INTEGER) {
        this._pid = 0;
      }
      return (++this._pid).toString();
    }

    /*
    Add callback and return it's ID. By default ID is a simple counter.
    Callbacks starts from 1 and up to Number.MAX_SAFE_INTEGER.
    Transfers as a string for case if server/client can have
    Number.MAX_SAFE_INTEGER less, then client/server and custom ID generators.
    @param {function} cb — callback function
    @return {string} id — callback's ID
    */
    addCallback(cb) {
      var id;
      id = this.newid();
      this._callbacks[id] = cb;
      return id;
    }

    /*
    Call method with next arguments.
    Mode (async/sync) depends on this.async flag.
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    method(method, ...args) {
      return this.methodApply(method, args);
    }

    /*
    Call method asynchronously with next arguments
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    methodAsync(method, ...args) {
      return this.methodAsyncApply(method, args);
    }

    /*
    Call method synchronously with next arguments
    @param {string} method — method name
    @param {object} ...args — arguments
    */
    methodSync(method, ...args) {
      return this.methodSyncApply(method, args);
    }

    /*
    Apply method asynchronously with arguments
    @param {string} method — method name
    @param {arrayLike} args — arguments array-like object (arguments)
    @param {array} args — arguments array
    */
    methodAsyncApply(method, args) {
      var cbs, convertedArgs, pid, promise;
      [convertedArgs, cbs] = argsConvertCb2Id(this, args);
      pid = this.newpid();
      promise = new Promise((resolve, reject) => {
        return this._promises[pid] = {resolve, reject};
      });
      this.request(new this.protocol.Method(method, pid, convertedArgs, cbs)); // Request sending
      return promise;
    }

    /*
    Apply method synchronously with arguments
    @param {string} method — method name
    @param {arrayLike} args — arguments array-like object (arguments)
    @param {array} args — arguments array
    */
    methodSyncApply(method, args) {
      var cbs, convertedArgs;
      [convertedArgs, cbs] = argsConvertCb2Id(this, args);
      return this.request(new this.protocol.Method(method, null, convertedArgs, cbs)); // Request sending
    }

    /*
    Create function-wrapper for API calls.
    Usefull for data preprocessing before send.
    Arguments of xt will be sended to client/server directly.
    Session and method's name is cahced.
    @param {string} method — method's name, will be cached
    @return {object} this
    */
    addMethod(method) {
      var api;
      api = this;
      this.methods[method] = function() {
        return api.methodApply(method, arguments);
      };
      return this;
    }

    /*
    Create function-wrapper for API calls for selected function.
    Allow to prepare arguments or callback for server.
    Session and name is cahced.
    @param {string} functionName — function name, will be cached
    @param {function} xt — function, will be called before request sending
    @param {function} xtThen — function, attached to promise via 'then' method
    @param {function} xtCatch — function, attached to promise via 'catch' method
    @return {object} this
    */
    createMethod(method, xt, mode, xtThen, xtCatch, safe = true) {
      var api, methods, mxt;
      api = this;
      methods = this.methods;
      if (safe && methods[method]) {
        return;
      }
      if (mode === void 0) {
        if (xt) {
          methods[method] = function() {
            return api.methodApply(method, xt.apply(api, arguments));
          };
        } else {
          methods[method] = function() {
            return api.methodApply(method, arguments);
          };
        }
      } else if (mode === 'async') {
        if (xtThen && xtCatch) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen).catch(xtCatch);
          } : function() {
            return api.methodAsyncApply(method, arguments).then(xtThen).catch(xtCatch);
          };
        } else if (xtThen) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).then(xtThen);
          } : function() {
            return api.methodAsyncApply(method, arguments).then(xtThen);
          };
        } else if (xtCatch) {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments)).catch(xtCatch);
          } : function() {
            return api.methodAsyncApply(method, arguments).catch(xtCatch);
          };
        } else {
          mxt = xt ? function() {
            return api.methodAsyncApply(method, xt.apply(api, arguments));
          } : function() {
            return api.methodAsyncApply(method, arguments);
          };
        }
        methods[method] = mxt;
      } else {
        methods[method] = xt ? function() {
          return api.methodSyncApply(method, xt.apply(api, arguments));
        } : function() {
          return api.methodSyncApply(method, arguments);
        };
      }
      return this;
    }

    /*
    Create API methods. Basically just wrap function into another function
    with cached context (API instance or session) and method name.
    @param {array} methodsList — string array with function names
    @param {object} methodsList — object with functions for data preprocessing
    @param {safe} safe — do not overwrite existsing methods (true by default)
    @return {object} this
    */
    addMethods(methodsList, safe) {
      var j, len, m, method, methods, name;
      methods = this.methods;
      if (Tools.isArray(methodsList)) {
        for (j = 0, len = methodsList.length; j < len; j++) {
          method = methodsList[j];
          if (Tools.isString(method)) {
            if (methods[method]) {
              continue;
            }
            this.addMethod(method);
          } else if (Tools.isObject(method)) {
            for (name in method) {
              if (!hasProp.call(method, name)) continue;
              m = method[name];
              if (methods[name]) {
                continue;
              }
              if (Tools.isFunction(m)) {
                this.createMethod(name, m, null, null, null, safe);
              } else {
                this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
              }
            }
          }
        }
      } else if (Tools.isObject(methodsList)) {
        for (name in methodsList) {
          if (!hasProp.call(methodsList, name)) continue;
          m = methodsList[name];
          if (methods[name]) {
            continue;
          }
          if (Tools.isFunction(m)) {
            this.createMethod(name, m, null, null, null, safe);
          } else {
            this.createMethod(name, m.method, m.mode, m.then, m.catch, safe);
          }
        }
      }
      return this;
    }

    /*
    Get info about server's API
    @param {string} [methodName] — methodName
    @param {function} cb — callback for result processing
    @return {object}
    */
    info(cb, options = {}) {
      var id;
      if (!Tools.isFunction(cb)) {
        throw new Error('Reqs.info() call without callback for data.');
      }
      // @request INFO: methodName, CB: @addCallback cb
      id = this.addCallback(cb);
      return this.request(new this.protocol.Info(id, options.events, options.methods));
    }

    /*
    Collect server's API methods list and create local client API methods
    @param {function} cb — callback
    @return {object} this
    */
    build(cb) {
      this.info((events, methods) => {
        this.addMethods(methods);
        if (Tools.isFunction(cb)) {
          return cb(events, methods);
        }
      });
      return this;
    }

    // ########################## #
    // --- Modules management --- #
    // ########################## #
    static addModule(m) {
      var modulesContainer;
      modulesContainer = this[m.category];
      if (!modulesContainer) {
        modulesContainer = this[m.category] = Tools.null();
      }
      modulesContainer[m.name] = m;
      return m;
    }

    // ########################### #
    // --- Sessions management --- #
    // ########################### #
    /*
    Create new session (child for current Reqs API)
    @param {object} [context][arg_1...arg_n] — user-defined argument
    or arguments for adding to session object as properties.
    If options.session.arguments is empty, then first argument will be
    saved to <Session>.context property.
    If options.session.arguments array is defined, then will be used
    this list of arguments names for defining the properties of session.
    @return {Session} session — session instance nested from Reqs API instance.
    */
    new() {
      var i, j, len, prop, ref, session;
      // Check for correct session creation: session must be
      // inherited from Reqs API instance, not from session.
      if (this.isSession) {
        throw new Error('<Reqs.Session instance>.new() used for new session creation. Use insted "<Reqs instance>.new()".');
      }
      // Creating of session instance nested from current Reqs API
      session = Object.create(this);
      // Adding user-defined properties
      if (arguments.length > 0) {
        ref = this.options.session.arguments;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          prop = ref[i];
          session[prop] = arguments[i];
        }
      }
      // Setting session properties
      session.isSession = true; // Is this object is session
      session.created = Date.now(); // Session creation date
      session.reqs = this; // Parent Reqs API instance
      session._callbacks = Tools.null(); // This session callbacks list
      session._id = 0; // Callbacks ID counter
      session._promises = Tools.null();
      session._pid = 0;
      session.methods = Tools.null(); // Session client API functions
      session.addMethods(this.options.methods); // Methods creation (required for caching session)
      return session;
    }

  };

  // ####################### #
  // --- Default options --- #
  // ####################### #

  // Is methods async (returns promise) or not (returns options.send result)
  Reqs.default = {
    mode: 'sync',
    coder: 'Coder',
    protocol: 'Protocol'
  };

  // ############### #
  // --- Modules --- #
  // ############### #
  Reqs.protocols = Tools.null({Protocol});

  Reqs.coders = Tools.null({Coder});

  // ############################## #
  // --- Tools and constructors --- #
  // ############################## #
  Reqs.Tools = Tools;

  Reqs.Protocol = Protocol;

  Reqs.Coder = Coder;

  /*
  Send compiled request to server/client.
  @param {string} data — data for sending (default: JSON string)
  */
  Reqs.prototype.send = console.info;

  // ###################################### #
  // --- Callbacks arguments converters --- #
  // ###################################### #
  argsConvertCb2Id = function(api, requestArgs = []) {
    var arg, args, cbs, i, j, len;
    args = [];
    cbs = [];
// Converting object to array
    for (i = j = 0, len = requestArgs.length; j < len; i = ++j) {
      arg = requestArgs[i];
      if (Tools.isFunction(arg)) {
        arg = api.addCallback(arg);
        cbs.push(Number.parseInt(i)); // For array-like objects 'arguments' case
      }
      args.push(arg);
    }
    if (cbs.length === 0) {
      cbs = null;
    }
    return [args, cbs];
  };

  argsConvertId2Cb = function(api, args = [], cbs) {
    var callbackId, id, j, len;
    if (cbs === void 0 || cbs.length === 0) {
      return args;
    }
// Converting object to array
    for (j = 0, len = cbs.length; j < len; j++) {
      id = cbs[j];
      callbackId = args[id];
      args[id] = api.createCallback(callbackId);
    }
    return args;
  };

  callbackRequest = function(api, id, cbArgs) {
    var args, cbs;
    [args, cbs] = argsConvertCb2Id(api, cbArgs);
    return api.request(new api.protocol.Callback(id, args, cbs)); // Request sending
  };

  return Reqs;

}).call(this);

module.exports = Reqs;

//# sourceMappingURL=reqs.js.map
;return module.exports})(this.module||{})