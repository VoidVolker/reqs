// Generated by CoffeeScript 2.5.1
var App, Server,
  hasProp = {}.hasOwnProperty;

Server = class Server {
  constructor() {}

  init(app) {
    var channels;
    this.channels = channels = {
      general: {
        history: [
          {
            author: 'Welcome',
            message: 'Welcome to #general channel'
          }
        ]
      }
    };
    return this.api = new Reqs({
      events: {
        syncPing: function(time) {
          var now;
          now = Date.now();
          return this.methods.pong(now - time, now);
        },
        asyncPing: function(time) {
          var now;
          now = Date.now();
          // throw new Error 'Some error'
          return [now - time, now];
        },
        message: function(channel, author, message) {
          var c;
          c = channels[channel];
          if (c) {
            c.history.push({
              author: author,
              message: message
            });
            return this.methods.message(channel, author, message);
          }
        },
        createChannel: function(channel) {
          var c, history;
          c = channels[channel];
          if (c) {
            return this.sendError('Channel already exists', 422, 'test id');
          } else {
            history = [
              {
                author: 'Welcome',
                message: `Welcome to #${channel} channel`
              }
            ];
            channels[channel] = {history};
            return this.methods.channelCreated(channel, history);
          }
        },
        history: function(cb) {
          if (cb) {
            return cb(channels);
          }
        },
        channelHistory: function(channel, cb) {
          var c;
          c = channels[channel];
          if (c && cb) {
            return cb(c.history);
          }
        }
      },
      methods: ['pong', 'message', 'channelCreated'],
      send: function(data) {
        console.log('<== RECEIVE local:', data);
        app.api.parse(data);
      },
      // coder:
      //     name: 'Coder'
      //     arguments: ['example key']
      key: 'example key',
      mode: 'sync' // By default all methods are sync
    });
  }

};

App = class App {
  constructor($1) {
    this.$ = $1;
    this.server = 'local';
    this.channels = {};
    this.$.send.click((e) => {
      var msg;
      msg = this.$.textbox.val();
      if (msg.length === 0) {
        return;
      }
      this.api.methods.message(this.selectedChannel, this.$.nickname.val(), msg);
      return this.$.textbox.val('');
    });
    this.$.createChannel.click((e) => {
      var name;
      name = this.$.channelName.val();
      if (name.length === 0) {
        return;
      }
      this.api.methods.createChannel(name);
      return this.$.channelName.val('');
    });
    this.$.server.change((e) => {
      this.server = this.$.server.val();
      if (this.server === 'ws') {
        return this.wsConnect();
      } else {
        return this.connect();
      }
    });
  }

  init(srv) {
    var app;
    app = this;
    this.api = new Reqs({
      events: {
        pong: function(t1, time) {
          var t2;
          t2 = Date.now() - time;
          return console.log(`Event: 'Pong'. Ping ${t1} + ${t2} = ${t1 + t2}`);
        },
        message: (channel, author, msg) => {
          // console.log "New message: <##{channel} [#{author}]: #{msg}>"
          return app.message(channel, author, msg);
        },
        channelCreated: function(channel, history) {
          return app.addChannel(channel, history);
        }
      },
      methods: [
        {
          cbPing: function() {
            return [
              Date.now(),
              function(t1,
              time) {
                var t2;
                t2 = Date.now() - time;
                return console.log(`Ping with callback result: ping ${t1} + ${t2} = ${t1 + t2}`);
              }
            ];
          },
          syncPing: {
            method: function() {
              return [Date.now()]; // Return array with arguments for method. Return result of 'send' function
            }
          },
          asyncPing: {
            mode: 'async',
            method: function() {
              return [Date.now()]; // Return array with arguments for method. Return promise.
            },
            // Optional function for promise.then() method
            then: function(result) {
              var t1,
        t2,
        time;
              t1 = result[0];
              time = result[1];
              t2 = Date.now() - time;
              return console.log(`asyncPing result: ${t1} + ${t2} = ${t1 + t2}`);
            },
            // Optional function for promise.catch() method
            catch: function(err) {
              return console.error('asyncPing error:',
        err);
            }
          },
          longMethodA: {
            mode: 'async',
            method: function() {
              console.log('Long method A started');
              return [];
            },
            then: function(result) {
              return console.log('Long method A result:',
        result);
            },
            catch: function(err) {
              return console.error('Long method A error:',
        err);
            }
          },
          longMethodB: function() {
            console.log('Long method B started');
            return [
              function(result) {
                return console.log('Long method B result:',
              result);
              }
            ];
          },
          // Example use:
          // app.api.methods.asyncPing()
          //   .then(function(result) {
          //       var t1 = result[0], time = result[1], t2 = Date.now()-time;
          //       console.log(`asyncPing result: ${t1} + ${t2} = ${t1 + t2}`);
          //   }).catch(function(err) { console.error('asyncPing error:', err) })
          history: function() {
            return [
              function(channels) {
                return app.setHistory(channels);
              }
            ];
          }
        },
        'message',
        'createChannel'
      ],
      send: function(data) { // Function for sending data
        console.log('==> SEND:', data);
        if (app.server === 'ws') {
          // Send data via WebSockets
          if (app.ws && app.ws.readyState === 1) {
            app.ws.send(data);
          }
        } else if (app.server === 'local') {
          // Send data to local server
          srv.api.parse(data);
        }
      },
      // coder:
      //     name: 'Coder'
      //     arguments: ['example key']
      key: 'example key',
      mode: 'sync' // Methods call mode for all methods whithout async/sync flag
    });
    srv.init(this);
    this.connect();
    return this;
  }

  connect() {
    this.api.methods.history();
    return this;
  }

  addChannel(channel, history = []) {
    var $c;
    if (this.channels[channel]) {
      return;
    }
    this.channels[channel] = {
      history: history
    };
    $c = $(`<div class='channel'>#${channel}</div>`);
    $c.click((e) => {
      return this.selectChannel(channel);
    });
    this.$.channels.append($c);
    return this;
  }

  setHistory(channels) {
    var c, name;
    this.$.channels.empty();
    this.channels = {};
    this.selectedChannel = null;
    for (name in channels) {
      if (!hasProp.call(channels, name)) continue;
      c = channels[name];
      this.addChannel(name, c.history);
      if (this.selectedChannel === null) {
        this.selectChannel(name);
      }
    }
    return this;
  }

  selectChannel(channel) {
    var c, i, len, m, msgs, ref;
    this.selectedChannel = channel;
    this.$.messages.empty();
    c = this.channels[channel];
    msgs = [];
    ref = c.history;
    for (i = 0, len = ref.length; i < len; i++) {
      m = ref[i];
      msgs.push(this.createMessage(m.author, m.message));
    }
    this.$.messages.html(msgs);
    return this;
  }

  createMessage(author, message) {
    return $(`<div class='message'>[<span class='author'>${author}</span>]: <span class='text'>${message}</span></div>`);
  }

  message(channel, author, message) {
    if (!this.channels[channel]) {
      this.addChannel(channel);
    }
    this.channels[channel].history.push({
      author: author,
      message: message
    });
    if (this.selectedChannel === channel) {
      this.$.messages.append(this.createMessage(author, message));
    }
    return this;
  }

  wsConnect() {
    var app, port;
    app = this;
    port = 3001;
    console.log('Connecting to WebSockets: ', port);
    if (this.ws) {
      this.ws.close();
    }
    return this.ws = new WS({
      host: 'localhost',
      port: port,
      open: function(e) {
        console.log('WS Connected to:', port);
        app.connect();
      },
      msg: function(e) {
        console.log('<== RECEIVE ws:', e.data);
        app.api.parse(e.data);
      },
      error: function(e) {
        console.error('WS connection error', e);
      },
      close: function(e) {
        delete app.session;
      }
    });
  }

};

$(function() {
  var srv;
  srv = window.SRV = new Server();
  return window.APP = new App({
    channels: $('.channels'),
    messages: $('.messages'),
    textbox: $('.textbox'),
    send: $('.send'),
    nickname: $('.nickname'),
    channelName: $('.channelName'),
    createChannel: $('.createChannel'),
    server: $('.server'),
    useHttpApi: $('#useHttpApi')
  }).init(srv);
});

// r = new Reqs(

//     send:
//         ws: (data) ->
//         ajax: (data) ->
// )

//# sourceMappingURL=client.js.map
