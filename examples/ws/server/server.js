// Generated by CoffeeScript 2.5.1
var Reqs, Server, express, host, httpPort, ws, wsPort;

express = require('express');

ws = require('nodejs-websocket');

Reqs = require('../../../dist/node/index.js');

httpPort = 3000;

wsPort = 3001;

host = 'localhost';

Server = class Server {
  constructor(send) {
    var channels, srv;
    srv = this;
    this.channels = channels = {
      general: {
        history: [
          {
            author: 'Welcome',
            message: 'Welcome to #general channel'
          }
        ]
      }
    };
    this.api = new Reqs({
      events: {
        cbPing: function(time, cb) {
          var now;
          now = Date.now();
          // throw new Error 'cbPing example error'
          return cb(now - time, now);
        },
        syncPing: function(time) {
          var now;
          now = Date.now();
          // throw new Error 'syncPing example error'
          return this.methods.pong(now - time, now);
        },
        asyncPing: function(time) {
          var now;
          now = Date.now();
          // throw new Error 'asyncPing example error'
          return [now - time, now];
        },
        longMethodA: function() {
          var p;
          p = new Promise(function(resolve, reject) {
            return setTimeout(function() {
              return resolve('Resolved A');
            }, 5000);
          });
          return p;
        },
        longMethodB: function(cb) {
          return setTimeout(function() {
            return cb('Resolved B');
          }, 5000);
        },
        message: function(channel, author, message) {
          var c, conn, i, len, ref, results;
          c = channels[channel];
          if (c) {
            c.history.push({
              author: author,
              message: message
            });
            ref = srv.wss.connections;
            // Broadcast message
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              conn = ref[i];
              if (conn.session) {
                results.push(conn.session.methods.message(channel, author, message));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        },
        createChannel: function(channel) {
          var c, conn, history, i, len, ref, results;
          c = channels[channel];
          if (c) {
            return this.sendError('Channel already exists', 422);
          } else {
            history = [
              {
                author: 'Welcome',
                message: `Welcome to #${channel} channel`
              }
            ];
            channels[channel] = {history};
            ref = srv.wss.connections;
            // Broadcast message
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              conn = ref[i];
              if (conn.session) {
                results.push(conn.session.methods.channelCreated(channel, history));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        },
        history: function(cb) {
          if (cb) {
            return cb(channels);
          }
        },
        channelHistory: function(channel, cb) {
          var c;
          c = channels[channel];
          if (c && cb) {
            return cb(c.history);
          }
        }
      },
      methods: ['pong', 'message', 'channelCreated'],
      send: function(data) {
        var conn;
        conn = this.conn;
        if (conn.readyState === conn.OPEN) { // Check connection state
          console.log('==> Sending response:', data);
          return conn.sendText(data);
        }
      },
      session: {
        arguments: 'conn' // Or ['a', 'b', 'c']
      },
      // coder:
      //     name: 'Coder'
      //     arguments: ['example key']
      key: 'example key',
      mode: 'sync' // By default all methods are sync
    });
    this.wss = ws.createServer(function(conn) {
      console.log('--- New connection! conn.path: ' + conn.path);
      // Create new ReqsAPI session
      conn.session = srv.api.new(conn);
      // Connection closing log
      conn.on('close', function(code, reason) {
        console.log('--- Connection closed', code, reason);
        delete conn.session;
      });
      // Conection errors handling (necessarily!)
      conn.on('error', function(err) {
        // This error happens when connections lost
        if (err.code === 'ECONNRESET') {

        } else {
          // console.error('--- Connection close error ECONNRESET');
          console.error('--- Connection error: ', err);
        }
      });
      // WS messages processing
      conn.on('text', function(text) {
        console.log('<== Incoming request:', text);
        return this.session.parse(text);
      });
    });
    this.app = express();
    this.app.use(express.static('./examples/ws/client/'));
    this.app.use('/dist/web/reqs.js', express.static('./dist/web/reqs.js'));
    this.app.listen(httpPort, function() {
      return console.log(`Example Http server listening: http://localhost:${httpPort}`);
    });
    this.wss.listen(wsPort, host);
    console.log(`Example WS Server listening: ws://localhost:${wsPort}`);
  }

};

global.SRV = new Server();

//# sourceMappingURL=server.js.map
